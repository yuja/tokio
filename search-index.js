var N = null;var searchIndex = {};
searchIndex["tokio"]={"doc":"A runtime for writing reliable, asynchronous, and slim applications.","items":[[0,"clock","tokio","A configurable source of time.",N,N],[5,"now","tokio::clock","Returns an `Instant` corresponding to \"now\".",N,[[],["instant"]]],[0,"executor","tokio","Task execution utilities.",N,N],[8,"Executor","tokio::executor","A value that executes futures.",N,N],[10,"spawn","","Spawns a future object to run on this executor.",0,[[["self"],["box",["future"]]],["result",["spawnerror"]]]],[11,"status","","Provides a best effort hint to whether or not `spawn` will succeed.",0,[[["self"]],["result",["spawnerror"]]]],[3,"DefaultExecutor","","Executes futures on the default executor for the current execution context.",N,N],[3,"SpawnError","","Errors returned by `Executor::spawn`.",N,N],[3,"Spawn","","Return value from the `spawn` function.",N,N],[5,"spawn","","Spawns a future on the default executor.",N,[[["f"]],["spawn"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"into_future","","",1,N],[0,"fs","tokio","Asynchronous filesystem manipulation operations.",N,N],[5,"create_dir","tokio::fs","Creates a new, empty directory at the provided path",N,[[["p"]],["createdirfuture"]]],[5,"create_dir_all","","Recursively create a directory and all of its parent components if they are missing.",N,[[["p"]],["createdirallfuture"]]],[0,"file","","Types for working with [`File`].",N,N],[3,"File","tokio::fs::file","A reference to an open file on the filesystem.",N,N],[3,"OpenFuture","","Future returned by `File::open` and resolves to a `File` instance.",N,N],[3,"OpenOptions","","Options and flags which can be used to configure how a file is opened.",N,N],[3,"CreateFuture","","Future returned by `File::create` and resolves to a `File` instance.",N,N],[3,"MetadataFuture","","Future returned by `File::metadata` and resolves to a `(Metadata, File)` instance.",N,N],[3,"SeekFuture","","Future returned by `File::seek`.",N,N],[5,"hard_link","tokio::fs","Creates a new hard link on the filesystem.",N,[[["p"],["q"]],["hardlinkfuture"]]],[5,"metadata","","Queries the file system metadata for a path.",N,[[["p"]],["metadatafuture"]]],[0,"os","","OS-specific functionality.",N,N],[0,"unix","tokio::fs::os","Unix-specific extensions to primitives in the `tokio_fs` module.",N,N],[5,"symlink","tokio::fs::os::unix","Creates a new symbolic link on the filesystem.",N,[[["p"],["q"]],["symlinkfuture"]]],[3,"SymlinkFuture","","Future returned by `symlink`.",N,N],[5,"read_dir","tokio::fs","Returns a stream over the entries within a directory.",N,[[["p"]],["readdirfuture"]]],[5,"read_link","","Reads a symbolic link, returning the file that the link points to.",N,[[["p"]],["readlinkfuture"]]],[5,"remove_dir","","Removes an existing, empty directory.",N,[[["p"]],["removedirfuture"]]],[5,"remove_file","","Removes a file from the filesystem.",N,[[["p"]],["removefilefuture"]]],[5,"rename","","Rename a file or directory to a new name, replacing the original file if `to` already exists.",N,[[["p"],["q"]],["renamefuture"]]],[5,"set_permissions","","Changes the permissions found on a file or a directory.",N,[[["p"],["permissions"]],["setpermissionsfuture"]]],[5,"symlink_metadata","","Queries the file system metadata for a path.",N,[[["p"]],["symlinkmetadatafuture"]]],[3,"File","","A reference to an open file on the filesystem.",N,N],[3,"OpenOptions","","Options and flags which can be used to configure how a file is opened.",N,N],[0,"net","tokio","TCP/UDP/Unix bindings for `tokio`.",N,N],[3,"TcpListener","tokio::net","An I/O object representing a TCP socket listening for incoming connections.",N,N],[3,"TcpStream","","An I/O object representing a TCP stream connected to a remote endpoint.",N,N],[3,"UdpFramed","","A unified `Stream` and `Sink` interface to an underlying `UdpSocket`, using the `Encoder` and `Decoder` traits to encode and decode frames.",N,N],[3,"UdpSocket","","An I/O object representing a UDP socket.",N,N],[3,"UnixListener","","A Unix socket which can accept connections from other Unix sockets.",N,N],[3,"UnixStream","","A structure representing a connected Unix socket.",N,N],[0,"tcp","","TCP bindings for `tokio`.",N,N],[3,"ConnectFuture","tokio::net::tcp","Future returned by `TcpStream::connect` which will resolve to a `TcpStream` when the stream is connected.",N,N],[3,"Incoming","","Stream returned by the `TcpListener::incoming` function representing the stream of sockets received from a listener.",N,N],[3,"TcpListener","","An I/O object representing a TCP socket listening for incoming connections.",N,N],[3,"TcpStream","","An I/O object representing a TCP stream connected to a remote endpoint.",N,N],[0,"udp","tokio::net","UDP bindings for `tokio`.",N,N],[3,"RecvDgram","tokio::net::udp","A future used to receive a datagram from a UDP socket.",N,N],[3,"SendDgram","","A future used to write the entire contents of some data to a UDP socket.",N,N],[3,"UdpFramed","","A unified `Stream` and `Sink` interface to an underlying `UdpSocket`, using the `Encoder` and `Decoder` traits to encode and decode frames.",N,N],[3,"UdpSocket","","An I/O object representing a UDP socket.",N,N],[0,"unix","tokio::net","Unix domain socket bindings for `tokio` (only available on unix systems).",N,N],[3,"ConnectFuture","tokio::net::unix","Future returned by `UnixStream::connect` which will resolve to a `UnixStream` when the stream is connected.",N,N],[3,"Incoming","","Stream of listeners",N,N],[3,"RecvDgram","","A future for receiving datagrams from a Unix datagram socket.",N,N],[3,"SendDgram","","A future for writing a buffer to a Unix datagram socket.",N,N],[3,"UCred","","Credentials of a process",N,N],[12,"uid","","UID (user ID) of the process",2,N],[12,"gid","","GID (group ID) of the process",2,N],[3,"UnixDatagram","","An I/O object representing a Unix datagram socket.",N,N],[3,"UnixListener","","A Unix socket which can accept connections from other Unix sockets.",N,N],[3,"UnixStream","","A structure representing a connected Unix socket.",N,N],[0,"reactor","tokio","Event loop that drives Tokio I/O resources.",N,N],[3,"Reactor","tokio::reactor","The core reactor, or event loop.",N,N],[3,"Handle","","A reference to a reactor.",N,N],[3,"Background","","Handle to the reactor running on a background thread.",N,N],[3,"Turn","","Return value from the `turn` method on `Reactor`.",N,N],[3,"Registration","","Associates an I/O resource with the reactor instance that drives it.",N,N],[3,"PollEvented2","","Associates an I/O resource that implements the [`std::io::Read`] and/or [`std::io::Write`] traits with the reactor that drives it.",N,N],[0,"runtime","tokio","A batteries included runtime for applications using Tokio.",N,N],[3,"Builder","tokio::runtime","Builds Tokio Runtime with custom configuration values.",N,N],[3,"Shutdown","","A future that resolves when the Tokio `Runtime` is shut down.",N,N],[3,"TaskExecutor","","Executes futures on the runtime",N,N],[3,"Runtime","","Handle to the Tokio runtime.",N,N],[5,"run","","Start the Tokio runtime using the supplied future to bootstrap execution.",N,[[["f"]]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"new","","Returns a new runtime builder initialized with default configuration values.",3,[[],["builder"]]],[11,"clock","","Set the `Clock` instance that will be used by the runtime.",3,[[["self"],["clock"]],["self"]]],[11,"core_threads","","Set the maximum number of worker threads for the `Runtime`'s thread pool.",3,[[["self"],["usize"]],["self"]]],[11,"blocking_threads","","Set the maximum number of concurrent blocking sections in the `Runtime`'s thread pool.",3,[[["self"],["usize"]],["self"]]],[11,"name_prefix","","Set name prefix of threads spawned by the `Runtime`'s thread pool.",3,[[["self"],["s"]],["self"]]],[11,"stack_size","","Set the stack size (in bytes) for worker threads.",3,[[["self"],["usize"]],["self"]]],[11,"build","","Create the configured `Runtime`.",3,[[["self"]],["result",["runtime"]]]],[0,"current_thread","","A runtime implementation that runs everything on the current thread.",N,N],[5,"spawn","tokio::runtime::current_thread","Executes a future on the current thread.",N,N],[3,"TaskExecutor","","Executes futures on the current thread.",N,N],[3,"Builder","","Builds a Single-threaded runtime with custom configuration values.",N,N],[3,"Runtime","","Single-threaded runtime provides a way to start reactor and executor on the current thread.",N,N],[3,"Handle","","Handle to spawn a future on the corresponding `CurrentThread` runtime instance",N,N],[5,"block_on_all","","Run the provided future to completion using a runtime running on the current thread.",N,[[["f"]],["result"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"new","","Returns a new runtime builder initialized with default configuration values.",4,[[],["builder"]]],[11,"clock","","Set the `Clock` instance that will be used by the runtime.",4,[[["self"],["clock"]],["self"]]],[11,"build","","Create the configured `Runtime`.",4,[[["self"]],["result",["runtime"]]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",6,[[["self"],["formatter"]],["result"]]],[11,"clone","","",6,[[["self"]],["handle"]]],[11,"spawn","","Spawn a future onto the `CurrentThread` runtime instance corresponding to this handle",6,[[["self"],["f"]],["result",["spawnerror"]]]],[11,"status","","Provides a best effort hint to whether or not `spawn` will succeed.",6,[[["self"]],["result",["spawnerror"]]]],[11,"execute","","",6,[[["self"],["t"]],["result",["executeerror"]]]],[11,"new","","Returns a new runtime initialized with default configuration values.",5,[[],["result",["runtime"]]]],[11,"handle","","Get a new handle to spawn futures on the single-threaded Tokio runtime",5,[[["self"]],["handle"]]],[11,"spawn","","Spawn a future onto the single-threaded Tokio runtime.",5,[[["self"],["f"]],["self"]]],[11,"block_on","","Runs the provided future, blocking the current thread until the future completes.",5,[[["self"],["f"]],["result"]]],[11,"run","","Run the executor to completion, blocking the thread until all spawned futures have completed.",5,[[["self"]],["result",["runerror"]]]],[11,"poll","tokio::runtime","",7,[[["self"]],["poll"]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result"]]],[11,"clone","","",8,[[["self"]],["taskexecutor"]]],[11,"spawn","","Spawn a future onto the Tokio runtime.",8,[[["self"],["f"]]]],[11,"execute","","",8,[[["self"],["t"]],["result",["executeerror"]]]],[11,"spawn","","",8,[[["self"],["box",["future"]]],["result",["spawnerror"]]]],[11,"fmt","","",9,[[["self"],["formatter"]],["result"]]],[11,"new","","Create a new runtime instance with default configuration values.",9,[[],["result"]]],[11,"reactor","","Return a reference to the reactor handle for this runtime instance.",9,[[["self"]],["handle"]]],[11,"executor","","Return a handle to the runtime's executor.",9,[[["self"]],["taskexecutor"]]],[11,"spawn","","Spawn a future onto the Tokio runtime.",9,[[["self"],["f"]],["self"]]],[11,"block_on","","Run a future to completion on the Tokio runtime.",9,[[["self"],["f"]],["result"]]],[11,"block_on_all","","Run a future to completion on the Tokio runtime, then wait for all background futures to complete too.",9,[[["self"],["f"]],["result"]]],[11,"shutdown_on_idle","","Signals the runtime to shutdown once it becomes idle.",9,[[["self"]],["shutdown"]]],[11,"shutdown_now","","Signals the runtime to shutdown immediately.",9,[[["self"]],["shutdown"]]],[11,"drop","","",9,[[["self"]]]],[0,"timer","tokio","Utilities for tracking time.",N,N],[0,"delay_queue","tokio::timer","A queue of delayed elements.",N,N],[3,"DelayQueue","tokio::timer::delay_queue","A queue of delayed elements.",N,N],[3,"Expired","","An entry in `DelayQueue` that has expired and removed.",N,N],[3,"Key","","Token to a value stored in a `DelayQueue`.",N,N],[3,"DelayQueue","tokio::timer","A queue of delayed elements.",N,N],[3,"Error","","Errors encountered by the timer implementation.",N,N],[3,"Interval","","A stream representing notifications at fixed interval",N,N],[3,"Delay","","A future that completes at a specified instant in time.",N,N],[3,"Timeout","","Allows a `Future` or `Stream` to execute for a limited amount of time.",N,N],[0,"timeout","","Allows a future or stream to execute for a maximum amount of time.",N,N],[3,"Timeout","tokio::timer::timeout","Allows a `Future` or `Stream` to execute for a limited amount of time.",N,N],[3,"Error","","Error returned by `Timeout`.",N,N],[0,"util","tokio","Utilities for working with Tokio.",N,N],[8,"FutureExt","tokio::util","An extension trait for `Future` that provides a variety of convenient combinator functions.",N,N],[11,"timeout","","Creates a new future which allows `self` until `timeout`.",10,[[["self"],["duration"]],["timeout"]]],[8,"StreamExt","","An extension trait for `Stream` that provides a variety of convenient combinator functions.",N,N],[11,"timeout","","Creates a new stream which allows `self` until `timeout`.",11,[[["self"],["duration"]],["timeout"]]],[0,"codec","tokio","Utilities for encoding and decoding frames.",N,N],[8,"Decoder","tokio::codec","Decoding of frames via buffers.",N,N],[16,"Item","","The type of decoded frames.",12,N],[16,"Error","","The type of unrecoverable frame decoding errors.",12,N],[10,"decode","","Attempts to decode a frame from the provided buffer of bytes.",12,[[["self"],["bytesmut"]],["result",["option"]]]],[11,"decode_eof","","A default method available to be called when there are no more bytes available to be read from the underlying I/O.",12,[[["self"],["bytesmut"]],["result",["option"]]]],[11,"framed","","Provides a `Stream` and `Sink` interface for reading and writing to this `Io` object, using `Decode` and `Encode` to read and write the raw data.",12,[[["self"],["t"]],["framed"]]],[8,"Encoder","","Trait of helper objects to write out messages as bytes, for use with `FramedWrite`.",N,N],[16,"Item","","The type of items consumed by the `Encoder`",13,N],[16,"Error","","The type of encoding errors.",13,N],[10,"encode","","Encodes a frame into the buffer provided.",13,N],[3,"Framed","","A unified `Stream` and `Sink` interface to an underlying I/O object, using the `Encoder` and `Decoder` traits to encode and decode frames.",N,N],[3,"FramedParts","","`FramedParts` contains an export of the data of a Framed transport. It can be used to construct a new `Framed` with a different codec. It contains all current buffers and the inner transport.",N,N],[12,"io","","The inner transport used to read bytes to and write bytes to",14,N],[12,"codec","","The codec",14,N],[12,"read_buf","","The buffer with read but unprocessed data.",14,N],[12,"write_buf","","A buffer with unprocessed data which are not written yet.",14,N],[3,"FramedRead","","A `Stream` of messages decoded from an `AsyncRead`.",N,N],[3,"FramedWrite","","A `Sink` of frames encoded to an `AsyncWrite`.",N,N],[3,"BytesCodec","","A simple `Codec` implementation that just ships bytes around.",N,N],[3,"LinesCodec","","A simple `Codec` implementation that splits up data into lines.",N,N],[3,"LengthDelimitedCodec","","A codec for frames delimited by a frame head specifying their lengths.",N,N],[0,"length_delimited","","Frame a stream of bytes based on a length prefix",N,N],[3,"Builder","tokio::codec::length_delimited","Configure length delimited `LengthDelimitedCodec`s.",N,N],[3,"FrameTooBig","","An error when the number of bytes read is more than max frame length.",N,N],[3,"LengthDelimitedCodec","","A codec for frames delimited by a frame head specifying their lengths.",N,N],[0,"io","tokio","Asynchronous I/O.",N,N],[8,"AsyncRead","tokio::io","Read bytes asynchronously.",N,N],[11,"prepare_uninitialized_buffer","","Prepares an uninitialized buffer to be safe to pass to `read`. Returns `true` if the supplied buffer was zeroed out.",15,N],[11,"poll_read","","Attempt to read from the `AsyncRead` into `buf`.",15,N],[11,"read_buf","","Pull some bytes from this source into the specified `Buf`, returning how many bytes were read.",15,[[["self"],["b"]],["result",["async","error"]]]],[11,"framed","","Provides a `Stream` and `Sink` interface for reading and writing to this `Io` object, using `Decode` and `Encode` to read and write the raw data.",15,[[["self"],["t"]],["framed"]]],[11,"split","","Helper method for splitting this read/write object into two halves.",15,N],[8,"AsyncWrite","","Writes bytes asynchronously.",N,N],[11,"poll_write","","Attempt to write bytes from `buf` into the object.",16,N],[11,"poll_flush","","Attempt to flush the object, ensuring that any buffered data reach their destination.",16,[[["self"]],["result",["async","error"]]]],[10,"shutdown","","Initiates or attempts to shut down this writer, returning success when the I/O connection has completely shut down.",16,[[["self"]],["result",["async","error"]]]],[11,"write_buf","","Write a `Buf` into this value, returning how many bytes were written.",16,[[["self"],["b"]],["result",["async","error"]]]],[5,"stdin","","Constructs a new handle to the standard input of the current process.",N,[[],["stdin"]]],[3,"Stdin","","A handle to the standard input stream of a process.",N,N],[5,"stdout","","Constructs a new handle to the standard output of the current process.",N,[[],["stdout"]]],[3,"Stdout","","A handle to the standard output stream of a process.",N,N],[5,"stderr","","Constructs a new handle to the standard error of the current process.",N,[[],["stderr"]]],[3,"Stderr","","A handle to the standard error stream of a process.",N,N],[5,"copy","","Creates a future which represents copying all the bytes from one object to another.",N,[[["r"],["w"]],["copy"]]],[3,"Copy","","A future which will copy all data from a reader into a writer.",N,N],[5,"flush","","Creates a future which will entirely flush an I/O object and then yield the object itself.",N,[[["a"]],["flush"]]],[3,"Flush","","A future used to fully flush an I/O object.",N,N],[5,"lines","","Creates a new stream from the I/O object given representing the lines of input that are found on `A`.",N,[[["a"]],["lines"]]],[3,"Lines","","Combinator created by the top-level `lines` method which is a stream over the lines of text on an I/O object.",N,N],[5,"read_exact","","Creates a future which will read exactly enough bytes to fill `buf`, returning an error if EOF is hit sooner.",N,[[["a"],["t"]],["readexact"]]],[3,"ReadExact","","A future which can be used to easily read exactly enough bytes to fill a buffer.",N,N],[5,"read_to_end","","Creates a future which will read all the bytes associated with the I/O object `A` into the buffer provided.",N,[[["a"],["vec",["u8"]]],["readtoend"]]],[3,"ReadToEnd","","A future which can be used to easily read the entire contents of a stream into a vector.",N,N],[5,"read_until","","Creates a future which will read all the bytes associated with the I/O object `A` into the buffer provided until the delimiter `byte` is reached. This method is the async equivalent to [`BufRead::read_until`].",N,[[["a"],["u8"],["vec",["u8"]]],["readuntil"]]],[3,"ReadUntil","","A future which can be used to easily read the contents of a stream into a vector until the delimiter is reached.",N,N],[3,"ReadHalf","","The readable half of an object returned from `AsyncRead::split`.",N,N],[5,"shutdown","","Creates a future which will entirely shutdown an I/O object and then yield the object itself.",N,[[["a"]],["shutdown"]]],[3,"Shutdown","","A future used to fully shutdown an I/O object.",N,N],[5,"write_all","","Creates a future that will write the entire contents of the buffer `buf` to the stream `a` provided.",N,[[["a"],["t"]],["writeall"]]],[3,"WriteAll","","A future used to write the entire contents of some data to a stream.",N,N],[3,"WriteHalf","","The writable half of an object returned from `AsyncRead::split`.",N,N],[3,"Error","","The error type for I/O operations of the [`Read`], [`Write`], [`Seek`], and associated traits.",N,N],[4,"ErrorKind","","A list specifying general categories of I/O error.",N,N],[13,"NotFound","","An entity was not found, often a file.",17,N],[13,"PermissionDenied","","The operation lacked the necessary privileges to complete.",17,N],[13,"ConnectionRefused","","The connection was refused by the remote server.",17,N],[13,"ConnectionReset","","The connection was reset by the remote server.",17,N],[13,"ConnectionAborted","","The connection was aborted (terminated) by the remote server.",17,N],[13,"NotConnected","","The network operation failed because it was not connected yet.",17,N],[13,"AddrInUse","","A socket address could not be bound because the address is already in use elsewhere.",17,N],[13,"AddrNotAvailable","","A nonexistent interface was requested or the requested address was not local.",17,N],[13,"BrokenPipe","","The operation failed because a pipe was closed.",17,N],[13,"AlreadyExists","","An entity already exists, often a file.",17,N],[13,"WouldBlock","","The operation needs to block to complete, but the blocking operation was requested to not occur.",17,N],[13,"InvalidInput","","A parameter was incorrect.",17,N],[13,"InvalidData","","Data not valid for the operation were encountered.",17,N],[13,"TimedOut","","The I/O operation's timeout expired, causing it to be canceled.",17,N],[13,"WriteZero","","An error returned when an operation could not be completed because a call to [`write`] returned [`Ok(0)`].",17,N],[13,"Interrupted","","This operation was interrupted.",17,N],[13,"Other","","Any I/O error not part of this list.",17,N],[13,"UnexpectedEof","","An error returned when an operation could not be completed because an \"end of file\" was reached prematurely.",17,N],[6,"Result","","A specialized `Result` type for I/O operations.",N,N],[8,"Read","","The `Read` trait allows for reading bytes from a source.",N,N],[10,"read","","Pull some bytes from this source into the specified buffer, returning how many bytes were read.",18,N],[11,"initializer","","Determines if this `Read`er can work with buffers of uninitialized memory.",18,[[["self"]],["initializer"]]],[11,"read_to_end","","Read all bytes until EOF in this source, placing them into `buf`.",18,[[["self"],["vec"]],["result",["usize","error"]]]],[11,"read_to_string","","Read all bytes until EOF in this source, appending them to `buf`.",18,[[["self"],["string"]],["result",["usize","error"]]]],[11,"read_exact","","Read the exact number of bytes required to fill `buf`.",18,N],[11,"by_ref","","Creates a \"by reference\" adaptor for this instance of `Read`.",18,[[["self"]],["self"]]],[11,"bytes","","Transforms this `Read` instance to an [`Iterator`] over its bytes.",18,[[["self"]],["bytes"]]],[11,"chars","","Transforms this `Read` instance to an [`Iterator`] over [`char`]s.",18,[[["self"]],["chars"]]],[11,"chain","","Creates an adaptor which will chain this stream with another.",18,[[["self"],["r"]],["chain"]]],[11,"take","","Creates an adaptor which will read at most `limit` bytes from it.",18,[[["self"],["u64"]],["take"]]],[8,"Write","","A trait for objects which are byte-oriented sinks.",N,N],[10,"write","","Write a buffer into this object, returning how many bytes were written.",19,N],[10,"flush","","Flush this output stream, ensuring that all intermediately buffered contents reach their destination.",19,[[["self"]],["result",["error"]]]],[11,"write_all","","Attempts to write an entire buffer into this write.",19,N],[11,"write_fmt","","Writes a formatted string into this writer, returning any error encountered.",19,[[["self"],["arguments"]],["result",["error"]]]],[11,"by_ref","","Creates a \"by reference\" adaptor for this instance of `Write`.",19,[[["self"]],["self"]]],[0,"prelude","tokio","A \"prelude\" for users of the `tokio` crate.",N,N],[8,"AsyncRead","tokio::prelude","Read bytes asynchronously.",N,N],[11,"prepare_uninitialized_buffer","","Prepares an uninitialized buffer to be safe to pass to `read`. Returns `true` if the supplied buffer was zeroed out.",15,N],[11,"poll_read","","Attempt to read from the `AsyncRead` into `buf`.",15,N],[11,"read_buf","","Pull some bytes from this source into the specified `Buf`, returning how many bytes were read.",15,[[["self"],["b"]],["result",["async","error"]]]],[11,"framed","","Provides a `Stream` and `Sink` interface for reading and writing to this `Io` object, using `Decode` and `Encode` to read and write the raw data.",15,[[["self"],["t"]],["framed"]]],[11,"split","","Helper method for splitting this read/write object into two halves.",15,N],[8,"AsyncWrite","","Writes bytes asynchronously.",N,N],[11,"poll_write","","Attempt to write bytes from `buf` into the object.",16,N],[11,"poll_flush","","Attempt to flush the object, ensuring that any buffered data reach their destination.",16,[[["self"]],["result",["async","error"]]]],[10,"shutdown","","Initiates or attempts to shut down this writer, returning success when the I/O connection has completely shut down.",16,[[["self"]],["result",["async","error"]]]],[11,"write_buf","","Write a `Buf` into this value, returning how many bytes were written.",16,[[["self"],["b"]],["result",["async","error"]]]],[8,"Read","","The `Read` trait allows for reading bytes from a source.",N,N],[10,"read","","Pull some bytes from this source into the specified buffer, returning how many bytes were read.",18,N],[11,"initializer","","Determines if this `Read`er can work with buffers of uninitialized memory.",18,[[["self"]],["initializer"]]],[11,"read_to_end","","Read all bytes until EOF in this source, placing them into `buf`.",18,[[["self"],["vec"]],["result",["usize","error"]]]],[11,"read_to_string","","Read all bytes until EOF in this source, appending them to `buf`.",18,[[["self"],["string"]],["result",["usize","error"]]]],[11,"read_exact","","Read the exact number of bytes required to fill `buf`.",18,N],[11,"by_ref","","Creates a \"by reference\" adaptor for this instance of `Read`.",18,[[["self"]],["self"]]],[11,"bytes","","Transforms this `Read` instance to an [`Iterator`] over its bytes.",18,[[["self"]],["bytes"]]],[11,"chars","","Transforms this `Read` instance to an [`Iterator`] over [`char`]s.",18,[[["self"]],["chars"]]],[11,"chain","","Creates an adaptor which will chain this stream with another.",18,[[["self"],["r"]],["chain"]]],[11,"take","","Creates an adaptor which will read at most `limit` bytes from it.",18,[[["self"],["u64"]],["take"]]],[8,"Write","","A trait for objects which are byte-oriented sinks.",N,N],[10,"write","","Write a buffer into this object, returning how many bytes were written.",19,N],[10,"flush","","Flush this output stream, ensuring that all intermediately buffered contents reach their destination.",19,[[["self"]],["result",["error"]]]],[11,"write_all","","Attempts to write an entire buffer into this write.",19,N],[11,"write_fmt","","Writes a formatted string into this writer, returning any error encountered.",19,[[["self"],["arguments"]],["result",["error"]]]],[11,"by_ref","","Creates a \"by reference\" adaptor for this instance of `Write`.",19,[[["self"]],["self"]]],[8,"Future","","Trait for types which are a placeholder of a value that may become available at some later point in time.",N,N],[16,"Item","","The type of value that this future will resolved with if it is successful.",20,N],[16,"Error","","The type of error that this future will resolve with if it fails in a normal fashion.",20,N],[10,"poll","","Query this future to see if its value has become available, registering interest if it is not.",20,[[["self"]],["result",["async"]]]],[11,"wait","","Block the current thread until this future is resolved.",20,[[["self"]],["result"]]],[11,"map","","Map this future's result to a different type, returning a new future of the resulting type.",20,[[["self"],["f"]],["map"]]],[11,"map_err","","Map this future's error to a different error, returning a new future.",20,[[["self"],["f"]],["maperr"]]],[11,"from_err","","Map this future's error to any error implementing `From` for this future's `Error`, returning a new future.",20,[[["self"]],["fromerr"]]],[11,"then","","Chain on a computation for when a future finished, passing the result of the future to the provided closure `f`.",20,[[["self"],["f"]],["then"]]],[11,"and_then","","Execute another future after this one has resolved successfully.",20,[[["self"],["f"]],["andthen"]]],[11,"or_else","","Execute another future if this one resolves with an error.",20,[[["self"],["f"]],["orelse"]]],[11,"select","","Waits for either one of two futures to complete.",20,[[["self"],["b"]],["select"]]],[11,"select2","","Waits for either one of two differently-typed futures to complete.",20,[[["self"],["b"]],["select2"]]],[11,"join","","Joins the result of two futures, waiting for them both to complete.",20,[[["self"],["b"]],["join"]]],[11,"join3","","Same as `join`, but with more futures.",20,[[["self"],["b"],["c"]],["join3"]]],[11,"join4","","Same as `join`, but with more futures.",20,[[["self"],["b"],["c"],["d"]],["join4"]]],[11,"join5","","Same as `join`, but with more futures.",20,[[["self"],["b"],["c"],["d"],["e"]],["join5"]]],[11,"into_stream","","Convert this future into a single element stream.",20,[[["self"]],["intostream"]]],[11,"flatten","","Flatten the execution of this future when the successful result of this future is itself another future.",20,[[["self"]],["flatten"]]],[11,"flatten_stream","","Flatten the execution of this future when the successful result of this future is a stream.",20,[[["self"]],["flattenstream"]]],[11,"fuse","","Fuse a future such that `poll` will never again be called once it has completed.",20,[[["self"]],["fuse"]]],[11,"inspect","","Do something with the item of a future, passing it on.",20,[[["self"],["f"]],["inspect"]]],[11,"catch_unwind","","Catches unwinding panics while polling the future.",20,[[["self"]],["catchunwind"]]],[11,"shared","","Create a cloneable handle to this future where all handles will resolve to the same result.",20,[[["self"]],["shared"]]],[0,"future","","Futures",N,N],[8,"Future","tokio::prelude::future","Trait for types which are a placeholder of a value that may become available at some later point in time.",N,N],[16,"Item","","The type of value that this future will resolved with if it is successful.",20,N],[16,"Error","","The type of error that this future will resolve with if it fails in a normal fashion.",20,N],[10,"poll","","Query this future to see if its value has become available, registering interest if it is not.",20,[[["self"]],["result",["async"]]]],[11,"wait","","Block the current thread until this future is resolved.",20,[[["self"]],["result"]]],[11,"map","","Map this future's result to a different type, returning a new future of the resulting type.",20,[[["self"],["f"]],["map"]]],[11,"map_err","","Map this future's error to a different error, returning a new future.",20,[[["self"],["f"]],["maperr"]]],[11,"from_err","","Map this future's error to any error implementing `From` for this future's `Error`, returning a new future.",20,[[["self"]],["fromerr"]]],[11,"then","","Chain on a computation for when a future finished, passing the result of the future to the provided closure `f`.",20,[[["self"],["f"]],["then"]]],[11,"and_then","","Execute another future after this one has resolved successfully.",20,[[["self"],["f"]],["andthen"]]],[11,"or_else","","Execute another future if this one resolves with an error.",20,[[["self"],["f"]],["orelse"]]],[11,"select","","Waits for either one of two futures to complete.",20,[[["self"],["b"]],["select"]]],[11,"select2","","Waits for either one of two differently-typed futures to complete.",20,[[["self"],["b"]],["select2"]]],[11,"join","","Joins the result of two futures, waiting for them both to complete.",20,[[["self"],["b"]],["join"]]],[11,"join3","","Same as `join`, but with more futures.",20,[[["self"],["b"],["c"]],["join3"]]],[11,"join4","","Same as `join`, but with more futures.",20,[[["self"],["b"],["c"],["d"]],["join4"]]],[11,"join5","","Same as `join`, but with more futures.",20,[[["self"],["b"],["c"],["d"],["e"]],["join5"]]],[11,"into_stream","","Convert this future into a single element stream.",20,[[["self"]],["intostream"]]],[11,"flatten","","Flatten the execution of this future when the successful result of this future is itself another future.",20,[[["self"]],["flatten"]]],[11,"flatten_stream","","Flatten the execution of this future when the successful result of this future is a stream.",20,[[["self"]],["flattenstream"]]],[11,"fuse","","Fuse a future such that `poll` will never again be called once it has completed.",20,[[["self"]],["fuse"]]],[11,"inspect","","Do something with the item of a future, passing it on.",20,[[["self"],["f"]],["inspect"]]],[11,"catch_unwind","","Catches unwinding panics while polling the future.",20,[[["self"]],["catchunwind"]]],[11,"shared","","Create a cloneable handle to this future where all handles will resolve to the same result.",20,[[["self"]],["shared"]]],[8,"IntoFuture","","Class of types which can be converted into a future.",N,N],[16,"Future","","The future that this type can be converted into.",21,N],[16,"Item","","The item that the future may resolve with.",21,N],[16,"Error","","The error that the future may resolve with.",21,N],[10,"into_future","","Consumes this object and produces a future.",21,N],[8,"FutureFrom","","Asynchronous conversion from a type `T`.",N,N],[16,"Future","","The future for the conversion.",22,N],[16,"Error","","Possible errors during conversion.",22,N],[10,"future_from","","Consume the given value, beginning the conversion.",22,N],[8,"Executor","","A trait for types which can spawn fresh futures.",N,N],[10,"execute","","Spawns a future to run on this `Executor`, typically in the \"background\".",23,[[["self"],["f"]],["result",["executeerror"]]]],[3,"ExecuteError","","Errors returned from the `Spawn::spawn` function.",N,N],[4,"ExecuteErrorKind","","Kinds of errors that can be returned from the `Execute::spawn` function.",N,N],[13,"Shutdown","","This executor has shut down and will no longer accept new futures to spawn.",24,N],[13,"NoCapacity","","This executor has no more capacity to run more futures. Other futures need to finish before this executor can accept another.",24,N],[5,"loop_fn","","Creates a new future implementing a tail-recursive loop.",N,[[["s"],["f"]],["loopfn"]]],[3,"Done","","A future representing a value that is immediately ready.",N,N],[3,"FlattenStream","","Future for the `flatten_stream` combinator, flattening a future-of-a-stream to get just the result of the final stream as a stream.",N,N],[3,"SharedError","","A wrapped error of the original future that is cloneable and implements Deref for ease of use.",N,N],[3,"MapErr","","Future for the `map_err` combinator, changing the error type of a future.",N,N],[4,"Loop","","The status of a `loop_fn` loop.",N,N],[13,"Break","","Indicates that the loop has completed with output `T`.",25,N],[13,"Continue","","Indicates that the loop function should be called again with input state `S`.",25,N],[5,"collect","","Creates a future which represents a collection of the results of the futures given.",N,[[["i"]],["joinall"]]],[4,"Either","","Combines two different futures yielding the same item and error types into a single type.",N,N],[13,"A","","First branch of the type",26,N],[13,"B","","Second branch of the type",26,N],[3,"SelectOk","","Future for the `select_ok` combinator, waiting for one of any of a list of futures to successfully complete. Unlike `select_all`, this future ignores all but the last error, if there are any.",N,N],[5,"select_ok","","Creates a new future which will select the first successful future over a list of futures.",N,[[["i"]],["selectok"]]],[3,"PollFn","","A future which adapts a function returning `Poll`.",N,N],[3,"SelectNext","","Future yielded as the second result in a `Select` future.",N,N],[5,"lazy","","Creates a new future which will eventually be the same as the one created by the closure provided.",N,[[["f"]],["lazy"]]],[3,"Join","","Future for the `join` combinator, waiting for two futures to complete.",N,N],[3,"SharedItem","","A wrapped item of the original future that is cloneable and implements Deref for ease of use.",N,N],[3,"Map","","Future for the `map` combinator, changing the type of a future.",N,N],[3,"Select2","","Future for the `select2` combinator, waiting for one of two differently-typed futures to complete.",N,N],[5,"finished","","Creates a \"leaf future\" from an immediate value of a finished and successful computation.",N,[[["t"]],["futureresult"]]],[5,"failed","","Creates a \"leaf future\" from an immediate value of a failed computation.",N,[[["e"]],["futureresult"]]],[3,"Join5","","Future for the `join5` combinator, waiting for five futures to complete.",N,N],[5,"poll_fn","","Creates a new future wrapping around a function returning `Poll`.",N,[[["f"]],["pollfn"]]],[3,"Select","","Future for the `select` combinator, waiting for one of two futures to complete.",N,N],[3,"Fuse","","A future which \"fuses\" a future once it's been resolved.",N,N],[3,"JoinAll","","A future which takes a list of futures and resolves with a vector of the completed values.",N,N],[5,"result","","Creates a new \"leaf future\" which will resolve with the given result.",N,[[["result"]],["futureresult"]]],[3,"CatchUnwind","","Future for the `catch_unwind` combinator.",N,N],[3,"OrElse","","Future for the `or_else` combinator, chaining a computation onto the end of a future which fails with an error.",N,N],[5,"select_all","","Creates a new future which will select over a list of futures.",N,[[["i"]],["selectall"]]],[3,"Inspect","","Do something with the item of a future, passing it on.",N,N],[3,"Join3","","Future for the `join3` combinator, waiting for three futures to complete.",N,N],[3,"Then","","Future for the `then` combinator, chaining computations on the end of another future regardless of its outcome.",N,N],[3,"Flatten","","Future for the `flatten` combinator, flattening a future-of-a-future to get just the result of the final future.",N,N],[3,"SelectAll","","Future for the `select_all` combinator, waiting for one of any of a list of futures to complete.",N,N],[3,"IntoStream","","Future that forwards one element from the underlying future (whether it is success of error) and emits EOF after that.",N,N],[3,"Empty","","A future which is never resolved.",N,N],[3,"Shared","","A future that is cloneable and can be polled in multiple threads. Use `Future::shared()` method to convert any future into a `Shared` future.",N,N],[3,"FromErr","","Future for the `from_err` combinator, changing the error type of a future.",N,N],[5,"empty","","Creates a future which never resolves, representing a computation that never finishes.",N,[[],["empty"]]],[3,"AndThen","","Future for the `and_then` combinator, chaining a computation onto the end of another future which completes successfully.",N,N],[3,"Join4","","Future for the `join4` combinator, waiting for four futures to complete.",N,N],[3,"LoopFn","","A future implementing a tail-recursive loop.",N,N],[3,"Lazy","","A future which defers creation of the actual future until a callback is scheduled.",N,N],[8,"Stream","tokio::prelude","A stream of values, not all of which may have been produced yet.",N,N],[16,"Item","","The type of item this stream will yield on success.",27,N],[16,"Error","","The type of error this stream may generate.",27,N],[10,"poll","","Attempt to pull out the next value of this stream, returning `None` if the stream is finished.",27,[[["self"]],["result",["async"]]]],[11,"wait","","Creates an iterator which blocks the current thread until each item of this stream is resolved.",27,[[["self"]],["wait"]]],[11,"into_future","","Converts this stream into a `Future`.",27,[[["self"]],["streamfuture"]]],[11,"map","","Converts a stream of type `T` to a stream of type `U`.",27,[[["self"],["f"]],["map"]]],[11,"map_err","","Converts a stream of error type `T` to a stream of error type `U`.",27,[[["self"],["f"]],["maperr"]]],[11,"filter","","Filters the values produced by this stream according to the provided predicate.",27,[[["self"],["f"]],["filter"]]],[11,"filter_map","","Filters the values produced by this stream while simultaneously mapping them to a different type.",27,[[["self"],["f"]],["filtermap"]]],[11,"then","","Chain on a computation for when a value is ready, passing the resulting item to the provided closure `f`.",27,[[["self"],["f"]],["then"]]],[11,"and_then","","Chain on a computation for when a value is ready, passing the successful results to the provided closure `f`.",27,[[["self"],["f"]],["andthen"]]],[11,"or_else","","Chain on a computation for when an error happens, passing the erroneous result to the provided closure `f`.",27,[[["self"],["f"]],["orelse"]]],[11,"collect","","Collect all of the values of this stream into a vector, returning a future representing the result of that computation.",27,[[["self"]],["collect"]]],[11,"concat2","","Concatenate all results of a stream into a single extendable destination, returning a future representing the end result.",27,[[["self"]],["concat2"]]],[11,"concat","","Concatenate all results of a stream into a single extendable destination, returning a future representing the end result.",27,[[["self"]],["concat"]]],[11,"fold","","Execute an accumulating computation over a stream, collecting all the values into one final result.",27,[[["self"],["t"],["f"]],["fold"]]],[11,"flatten","","Flattens a stream of streams into just one continuous stream.",27,[[["self"]],["flatten"]]],[11,"skip_while","","Skip elements on this stream while the predicate provided resolves to `true`.",27,[[["self"],["p"]],["skipwhile"]]],[11,"take_while","","Take elements from this stream while the predicate provided resolves to `true`.",27,[[["self"],["p"]],["takewhile"]]],[11,"for_each","","Runs this stream to completion, executing the provided closure for each element on the stream.",27,[[["self"],["f"]],["foreach"]]],[11,"from_err","","Map this stream's error to any error implementing `From` for this stream's `Error`, returning a new stream.",27,[[["self"]],["fromerr"]]],[11,"take","","Creates a new stream of at most `amt` items of the underlying stream.",27,[[["self"],["u64"]],["take"]]],[11,"skip","","Creates a new stream which skips `amt` items of the underlying stream.",27,[[["self"],["u64"]],["skip"]]],[11,"fuse","","Fuse a stream such that `poll` will never again be called once it has finished.",27,[[["self"]],["fuse"]]],[11,"by_ref","","Borrows a stream, rather than consuming it.",27,[[["self"]],["self"]]],[11,"catch_unwind","","Catches unwinding panics while polling the stream.",27,[[["self"]],["catchunwind"]]],[11,"buffered","","An adaptor for creating a buffered list of pending futures.",27,[[["self"],["usize"]],["buffered"]]],[11,"buffer_unordered","","An adaptor for creating a buffered list of pending futures (unordered).",27,[[["self"],["usize"]],["bufferunordered"]]],[11,"merge","","An adapter for merging the output of two streams.",27,[[["self"],["s"]],["merge"]]],[11,"zip","","An adapter for zipping two streams together.",27,[[["self"],["s"]],["zip"]]],[11,"chain","","Adapter for chaining two stream.",27,[[["self"],["s"]],["chain"]]],[11,"peekable","","Creates a new stream which exposes a `peek` method.",27,[[["self"]],["peekable"]]],[11,"chunks","","An adaptor for chunking up items of the stream inside a vector.",27,[[["self"],["usize"]],["chunks"]]],[11,"select","","Creates a stream that selects the next element from either this stream or the provided one, whichever is ready first.",27,[[["self"],["s"]],["select"]]],[11,"forward","","A future that completes after the given stream has been fully processed into the sink, including flushing.",27,[[["self"],["s"]],["forward"]]],[11,"split","","Splits this `Stream + Sink` object into separate `Stream` and `Sink` objects.",27,N],[11,"inspect","","Do something with each item of this stream, afterwards passing it on.",27,[[["self"],["f"]],["inspect"]]],[11,"inspect_err","","Do something with the error of this stream, afterwards passing it on.",27,[[["self"],["f"]],["inspecterr"]]],[0,"stream","","Asynchronous streams",N,N],[0,"futures_unordered","tokio::prelude::stream","An unbounded set of futures.",N,N],[3,"FuturesUnordered","tokio::prelude::stream::futures_unordered","An unbounded set of futures.",N,N],[3,"IterMut","","Mutable iterator over all futures in the unordered set.",N,N],[8,"Stream","tokio::prelude::stream","A stream of values, not all of which may have been produced yet.",N,N],[16,"Item","","The type of item this stream will yield on success.",27,N],[16,"Error","","The type of error this stream may generate.",27,N],[10,"poll","","Attempt to pull out the next value of this stream, returning `None` if the stream is finished.",27,[[["self"]],["result",["async"]]]],[11,"wait","","Creates an iterator which blocks the current thread until each item of this stream is resolved.",27,[[["self"]],["wait"]]],[11,"into_future","","Converts this stream into a `Future`.",27,[[["self"]],["streamfuture"]]],[11,"map","","Converts a stream of type `T` to a stream of type `U`.",27,[[["self"],["f"]],["map"]]],[11,"map_err","","Converts a stream of error type `T` to a stream of error type `U`.",27,[[["self"],["f"]],["maperr"]]],[11,"filter","","Filters the values produced by this stream according to the provided predicate.",27,[[["self"],["f"]],["filter"]]],[11,"filter_map","","Filters the values produced by this stream while simultaneously mapping them to a different type.",27,[[["self"],["f"]],["filtermap"]]],[11,"then","","Chain on a computation for when a value is ready, passing the resulting item to the provided closure `f`.",27,[[["self"],["f"]],["then"]]],[11,"and_then","","Chain on a computation for when a value is ready, passing the successful results to the provided closure `f`.",27,[[["self"],["f"]],["andthen"]]],[11,"or_else","","Chain on a computation for when an error happens, passing the erroneous result to the provided closure `f`.",27,[[["self"],["f"]],["orelse"]]],[11,"collect","","Collect all of the values of this stream into a vector, returning a future representing the result of that computation.",27,[[["self"]],["collect"]]],[11,"concat2","","Concatenate all results of a stream into a single extendable destination, returning a future representing the end result.",27,[[["self"]],["concat2"]]],[11,"concat","","Concatenate all results of a stream into a single extendable destination, returning a future representing the end result.",27,[[["self"]],["concat"]]],[11,"fold","","Execute an accumulating computation over a stream, collecting all the values into one final result.",27,[[["self"],["t"],["f"]],["fold"]]],[11,"flatten","","Flattens a stream of streams into just one continuous stream.",27,[[["self"]],["flatten"]]],[11,"skip_while","","Skip elements on this stream while the predicate provided resolves to `true`.",27,[[["self"],["p"]],["skipwhile"]]],[11,"take_while","","Take elements from this stream while the predicate provided resolves to `true`.",27,[[["self"],["p"]],["takewhile"]]],[11,"for_each","","Runs this stream to completion, executing the provided closure for each element on the stream.",27,[[["self"],["f"]],["foreach"]]],[11,"from_err","","Map this stream's error to any error implementing `From` for this stream's `Error`, returning a new stream.",27,[[["self"]],["fromerr"]]],[11,"take","","Creates a new stream of at most `amt` items of the underlying stream.",27,[[["self"],["u64"]],["take"]]],[11,"skip","","Creates a new stream which skips `amt` items of the underlying stream.",27,[[["self"],["u64"]],["skip"]]],[11,"fuse","","Fuse a stream such that `poll` will never again be called once it has finished.",27,[[["self"]],["fuse"]]],[11,"by_ref","","Borrows a stream, rather than consuming it.",27,[[["self"]],["self"]]],[11,"catch_unwind","","Catches unwinding panics while polling the stream.",27,[[["self"]],["catchunwind"]]],[11,"buffered","","An adaptor for creating a buffered list of pending futures.",27,[[["self"],["usize"]],["buffered"]]],[11,"buffer_unordered","","An adaptor for creating a buffered list of pending futures (unordered).",27,[[["self"],["usize"]],["bufferunordered"]]],[11,"merge","","An adapter for merging the output of two streams.",27,[[["self"],["s"]],["merge"]]],[11,"zip","","An adapter for zipping two streams together.",27,[[["self"],["s"]],["zip"]]],[11,"chain","","Adapter for chaining two stream.",27,[[["self"],["s"]],["chain"]]],[11,"peekable","","Creates a new stream which exposes a `peek` method.",27,[[["self"]],["peekable"]]],[11,"chunks","","An adaptor for chunking up items of the stream inside a vector.",27,[[["self"],["usize"]],["chunks"]]],[11,"select","","Creates a stream that selects the next element from either this stream or the provided one, whichever is ready first.",27,[[["self"],["s"]],["select"]]],[11,"forward","","A future that completes after the given stream has been fully processed into the sink, including flushing.",27,[[["self"],["s"]],["forward"]]],[11,"split","","Splits this `Stream + Sink` object into separate `Stream` and `Sink` objects.",27,N],[11,"inspect","","Do something with each item of this stream, afterwards passing it on.",27,[[["self"],["f"]],["inspect"]]],[11,"inspect_err","","Do something with the error of this stream, afterwards passing it on.",27,[[["self"],["f"]],["inspecterr"]]],[5,"futures_unordered","","Converts a list of futures into a `Stream` of results from the futures.",N,[[["i"]],["futuresunordered"]]],[3,"InspectErr","","Do something with the error of a stream, passing it on.",N,N],[3,"Peekable","","A `Stream` that implements a `peek` method.",N,N],[5,"iter_ok","","Converts an `Iterator` into a `Stream` which is always ready to yield the next value.",N,[[["i"]],["iterok"]]],[3,"IterStream","","A stream which is just a shim over an underlying instance of `Iterator`.",N,N],[3,"TakeWhile","","A stream combinator which takes elements from a stream while a predicate holds.",N,N],[3,"Wait","","A stream combinator which converts an asynchronous stream to a blocking iterator.",N,N],[3,"MapErr","","A stream combinator which will change the error type of a stream from one type to another.",N,N],[3,"Take","","A stream combinator which returns a maximum number of elements.",N,N],[3,"Receiver","","The receiving end of a channel which implements the `Stream` trait.",N,N],[3,"ReuniteError","","Error indicating a `SplitSink<S>` and `SplitStream<S>` were not two halves of a `Stream + Split`, and thus could not be `reunite`d.",N,N],[12,"0","","",28,N],[12,"1","","",28,N],[3,"Once","","A stream which emits single element and then EOF.",N,N],[3,"PollFn","","A stream which adapts a function returning `Poll`.",N,N],[3,"Chain","","An adapter for chaining the output of two streams.",N,N],[3,"Zip","","An adapter for merging the output of two streams.",N,N],[5,"channel","","Creates an in-memory channel implementation of the `Stream` trait.",N,N],[3,"BufferUnordered","","An adaptor for a stream of futures to execute the futures concurrently, if possible, delivering results as they become available.",N,N],[3,"Sender","","The transmission end of a channel which is used to send values.",N,N],[3,"Map","","A stream combinator which will change the type of a stream from one type to another.",N,N],[3,"Skip","","A stream combinator which skips a number of elements before continuing.",N,N],[5,"poll_fn","","Creates a new stream wrapping around a function returning `Poll`.",N,[[["f"]],["pollfn"]]],[3,"Repeat","","Stream that produces the same element repeatedly.",N,N],[5,"once","","Creates a stream of single element",N,[[["result"]],["once"]]],[3,"FutureSender","","Future returned by `Sender::send`.",N,N],[3,"Select","","An adapter for merging the output of two streams.",N,N],[3,"Concat","","A stream combinator to concatenate the results of a stream into the first yielded item.",N,N],[3,"Fuse","","A stream which \"fuse\"s a stream once it's terminated.",N,N],[5,"repeat","","Create a stream which produces the same item repeatedly.",N,[[["t"]],["repeat"]]],[3,"CatchUnwind","","Stream for the `catch_unwind` combinator.",N,N],[3,"FilterMap","","A combinator used to filter the results of a stream and simultaneously map them to a different type.",N,N],[3,"OrElse","","A stream combinator which chains a computation onto errors produced by a stream.",N,N],[3,"Inspect","","Do something with the items of a stream, passing it on.",N,N],[3,"Filter","","A stream combinator used to filter the results of a stream and only yield some values.",N,N],[3,"IterResult","","A stream which is just a shim over an underlying instance of `Iterator`.",N,N],[5,"iter_result","","Converts an `Iterator` over `Result`s into a `Stream` which is always ready to yield the next value.",N,[[["j"]],["iterresult"]]],[3,"SendError","","Error type for sending, used when the receiving end of the channel is dropped",N,N],[3,"Then","","A stream combinator which chains a computation onto each item produced by a stream.",N,N],[3,"Forward","","Future for the `Stream::forward` combinator, which sends a stream of values to a sink and then waits until the sink has fully flushed those values.",N,N],[5,"unfold","","Creates a `Stream` from a seed and a closure returning a `Future`.",N,[[["t"],["f"]],["unfold"]]],[3,"Flatten","","A combinator used to flatten a stream-of-streams into one long stream of elements.",N,N],[3,"Chunks","","An adaptor that chunks up elements in a vector.",N,N],[3,"StreamFuture","","A combinator used to temporarily convert a stream into a future.",N,N],[3,"SkipWhile","","A stream combinator which skips elements of a stream while a predicate holds.",N,N],[5,"iter","","Converts an `Iterator` over `Result`s into a `Stream` which is always ready to yield the next value.",N,[[["j"]],["iter"]]],[3,"Concat2","","A stream combinator to concatenate the results of a stream into the first yielded item.",N,N],[3,"ForEach","","A stream combinator which executes a unit closure over each item on a stream.",N,N],[3,"SplitSink","","A `Sink` part of the split pair",N,N],[4,"MergedItem","","An item returned from a merge stream, which represents an item from one or both of the underlying streams.",N,N],[13,"First","","An item from the first stream",29,N],[13,"Second","","An item from the second stream",29,N],[13,"Both","","Items from both streams",29,N],[3,"Empty","","A stream which contains no elements.",N,N],[3,"IterOk","","A stream which is just a shim over an underlying instance of `Iterator`.",N,N],[3,"FromErr","","A stream combinator to change the error type of a stream.",N,N],[3,"Collect","","A future which collects all of the values of a stream into a vector.",N,N],[3,"Unfold","","A stream which creates futures, polls them and return their result",N,N],[3,"Merge","","An adapter for merging the output of two streams.",N,N],[5,"empty","","Creates a stream which contains no elements.",N,[[],["empty"]]],[3,"AndThen","","A stream combinator which chains a computation onto values produced by a stream.",N,N],[3,"Buffered","","An adaptor for a stream of futures to execute the futures concurrently, if possible.",N,N],[5,"futures_ordered","","Converts a list of futures into a `Stream` of results from the futures.",N,[[["i"]],["futuresordered"]]],[3,"Fold","","A future used to collect all the results of a stream into one generic type.",N,N],[3,"FuturesOrdered","","An unbounded queue of futures.",N,N],[3,"SplitStream","","A `Stream` part of the split pair",N,N],[8,"Sink","tokio::prelude","A `Sink` is a value into which other values can be sent, asynchronously.",N,N],[16,"SinkItem","","The type of value that the sink accepts.",30,N],[16,"SinkError","","The type of value produced by the sink when an error occurs.",30,N],[10,"start_send","","Begin the process of sending a value to the sink.",30,N],[10,"poll_complete","","Flush all output from this sink, if necessary.",30,[[["self"]],["result",["async"]]]],[11,"close","","A method to indicate that no more values will ever be pushed into this sink.",30,[[["self"]],["result",["async"]]]],[11,"wait","","Creates a new object which will produce a synchronous sink.",30,[[["self"]],["wait"]]],[11,"with","","Composes a function in front of the sink.",30,[[["self"],["f"]],["with"]]],[11,"with_flat_map","","Composes a function in front of the sink.",30,[[["self"],["f"]],["withflatmap"]]],[11,"sink_map_err","","Transforms the error returned by the sink.",30,[[["self"],["f"]],["sinkmaperr"]]],[11,"sink_from_err","","Map this sink's error to any error implementing `From` for this sink's `Error`, returning a new sink.",30,[[["self"]],["sinkfromerr"]]],[11,"buffer","","Adds a fixed-size buffer to the current sink.",30,[[["self"],["usize"]],["buffer"]]],[11,"fanout","","Fanout items to multiple sinks.",30,[[["self"],["s"]],["fanout"]]],[11,"flush","","A future that completes when the sink has finished processing all pending requests.",30,[[["self"]],["flush"]]],[11,"send","","A future that completes after the given item has been fully processed into the sink, including flushing.",30,N],[11,"send_all","","A future that completes after the given stream has been fully processed into the sink, including flushing.",30,[[["self"],["s"]],["sendall"]]],[8,"IntoFuture","","Class of types which can be converted into a future.",N,N],[16,"Future","","The future that this type can be converted into.",21,N],[16,"Item","","The item that the future may resolve with.",21,N],[16,"Error","","The error that the future may resolve with.",21,N],[10,"into_future","","Consumes this object and produces a future.",21,N],[4,"Async","","Return type of future, indicating whether a value is ready or not.",N,N],[13,"Ready","","Represents that a value is immediately ready.",31,N],[13,"NotReady","","Represents that a value is not ready yet, but may be so later.",31,N],[4,"AsyncSink","","The result of an asynchronous attempt to send a value to a sink.",N,N],[13,"Ready","","The `start_send` attempt succeeded, so the sending process has started; you must use `Sink::poll_complete` to drive the send to completion.",32,N],[13,"NotReady","","The `start_send` attempt failed due to the sink being full. The value being sent is returned, and the current `Task` will be automatically notified again once the sink has room.",32,N],[6,"Poll","","Return type of the `Future::poll` method, indicates whether a future's value is ready or not.",N,N],[0,"task","","Tasks used to drive a future computation",N,N],[3,"LocalKey","tokio::prelude::task","A key for task-local data stored in a future's task.",N,N],[3,"Run","","Units of work submitted to an `Executor`, currently only created internally.",N,N],[5,"with_unpark_event","","For the duration of the given callback, add an \"unpark event\" to be triggered when the task handle is used to unpark the task.",N,[[["unparkevent"],["f"]],["r"]]],[3,"UnparkEvent","","A set insertion to trigger upon `unpark`.",N,N],[5,"current","","Returns a handle to the current task to call `notify` at a later date.",N,[[],["task"]]],[3,"Spawn","","Representation of a spawned future/stream.",N,N],[8,"Unpark","","A trait which represents a sink of notifications that a future is ready to make progress.",N,N],[10,"unpark","","Indicates that an associated future and/or task are ready to make progress.",33,N],[3,"Task","","A handle to a \"task\", which represents a single lightweight \"thread\" of execution driving a future to completion.",N,N],[3,"AtomicTask","","A synchronization primitive for task notification.",N,N],[3,"TaskRc","","A reference to a piece of data that's accessible only within a specific `Task`.",N,N],[8,"Executor","","A trait representing requests to poll futures.",N,N],[10,"execute","","Requests that `Run` is executed soon on the given executor.",34,N],[5,"init","","Initialize the `futures` task system.",N,N],[8,"EventSet","","A concurrent set which allows for the insertion of `usize` values.",N,N],[10,"insert","","Insert the given ID into the set",35,N],[5,"spawn","","Spawns a future or stream, returning it and the new task responsible for running it to completion.",N,[[["t"]],["spawn"]]],[8,"FutureExt","tokio::prelude","An extension trait for `Future` that provides a variety of convenient combinator functions.",N,N],[11,"timeout","tokio::util","Creates a new future which allows `self` until `timeout`.",10,[[["self"],["duration"]],["timeout"]]],[8,"StreamExt","tokio::prelude","An extension trait for `Stream` that provides a variety of convenient combinator functions.",N,N],[11,"timeout","tokio::util","Creates a new stream which allows `self` until `timeout`.",11,[[["self"],["duration"]],["timeout"]]],[11,"cmp","tokio::io","",17,[[["self"],["errorkind"]],["ordering"]]],[11,"clone","","",17,[[["self"]],["errorkind"]]],[11,"fmt","","",17,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",36,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",36,[[["self"],["formatter"]],["result",["error"]]]],[11,"description","","",36,[[["self"]],["str"]]],[11,"cause","","",36,[[["self"]],["option",["error"]]]],[11,"eq","","",17,[[["self"],["errorkind"]],["bool"]]],[11,"from","","",36,[[["errorkind"]],["error"]]],[11,"from","","",36,[[["nulerror"]],["error"]]],[11,"from","","",36,[[["intoinnererror"]],["error"]]],[11,"hash","","",17,N],[11,"partial_cmp","","",17,[[["self"],["errorkind"]],["option",["ordering"]]]],[11,"default","tokio::prelude::task","",37,[[],["atomictask"]]],[11,"poll","tokio::prelude::future","",38,[[["self"]],["result",["async"]]]],[11,"poll","","",39,[[["self"]],["result",["async"]]]],[11,"poll","tokio::prelude::stream","",40,[[["self"]],["result",["async"]]]],[11,"poll","tokio::prelude::future","",41,[[["self"]],["result",["async"]]]],[11,"poll","","",42,[[["self"]],["result",["async"]]]],[11,"poll","","",43,[[["self"]],["result",["async"]]]],[11,"poll","","",26,[[["self"]],["result",["async"]]]],[11,"poll","","",44,[[["self"]],["result",["async"]]]],[11,"poll","","",45,[[["self"]],["result",["async"]]]],[11,"poll","","",46,[[["self"]],["result",["async"]]]],[11,"poll","","",47,[[["self"]],["result",["async"]]]],[11,"poll","","",48,[[["self"]],["result",["async"]]]],[11,"poll","tokio::prelude::stream","",49,[[["self"]],["result",["async"]]]],[11,"poll","tokio::prelude::future","",50,[[["self"]],["result",["async"]]]],[11,"poll","","",51,[[["self"]],["result",["async"]]]],[11,"poll","","",52,[[["self"]],["result",["async"]]]],[11,"poll","tokio::prelude::stream","",53,[[["self"]],["result",["async"]]]],[11,"poll","","",54,[[["self"]],["result",["async"]]]],[11,"poll","tokio::prelude::future","",55,[[["self"]],["result",["async"]]]],[11,"poll","","",56,[[["self"]],["result",["async"]]]],[11,"poll","","",57,[[["self"]],["result",["async"]]]],[11,"poll","","",58,[[["self"]],["result",["async"]]]],[11,"poll","","",59,[[["self"]],["result",["async"]]]],[11,"poll","","",60,[[["self"]],["result",["async"]]]],[11,"poll","","",61,[[["self"]],["result",["async"]]]],[11,"poll","","",62,[[["self"]],["result",["async"]]]],[11,"poll","tokio::prelude::stream","",63,[[["self"]],["result",["async"]]]],[11,"poll","tokio::prelude::future","",64,[[["self"]],["result",["async"]]]],[11,"poll","","",65,[[["self"]],["result",["async"]]]],[11,"poll","","",66,[[["self"]],["result",["async"]]]],[11,"poll","tokio::prelude::stream","",67,[[["self"]],["result",["async"]]]],[11,"poll","","",68,[[["self"]],["result",["async"]]]],[11,"poll","tokio::prelude::future","",69,[[["self"]],["result",["async"]]]],[11,"poll","","",70,[[["self"]],["result",["async"]]]],[11,"poll","tokio::prelude::stream","",71,[[["self"]],["result",["async"]]]],[11,"from_iter","","",72,[[["t"]],["futuresordered"]]],[11,"from_iter","tokio::prelude::stream::futures_unordered","",73,[[["t"]],["futuresunordered"]]],[11,"start_send","tokio::prelude::stream","",74,N],[11,"poll_complete","","",74,[[["self"]],["result",["async"]]]],[11,"close","","",74,[[["self"]],["result",["async"]]]],[11,"start_send","","",75,N],[11,"poll_complete","","",75,[[["self"]],["result",["async"]]]],[11,"close","","",75,[[["self"]],["result",["async"]]]],[11,"start_send","","",76,N],[11,"poll_complete","","",76,[[["self"]],["result",["async"]]]],[11,"close","","",76,[[["self"]],["result",["async"]]]],[11,"start_send","","",77,N],[11,"poll_complete","","",77,[[["self"]],["result",["async"]]]],[11,"close","","",77,[[["self"]],["result",["async"]]]],[11,"start_send","","",78,N],[11,"poll_complete","","",78,[[["self"]],["result",["async"]]]],[11,"close","","",78,[[["self"]],["result",["async"]]]],[11,"start_send","","",79,N],[11,"poll_complete","","",79,[[["self"]],["result",["async"]]]],[11,"close","","",79,[[["self"]],["result",["async"]]]],[11,"start_send","","",80,N],[11,"poll_complete","","",80,[[["self"]],["result",["async"]]]],[11,"close","","",80,[[["self"]],["result",["async"]]]],[11,"start_send","","",81,N],[11,"poll_complete","","",81,[[["self"]],["result",["async"]]]],[11,"close","","",81,[[["self"]],["result",["async"]]]],[11,"start_send","","",82,N],[11,"poll_complete","","",82,[[["self"]],["result",["async"]]]],[11,"close","","",82,[[["self"]],["result",["async"]]]],[11,"start_send","","",83,N],[11,"poll_complete","","",83,[[["self"]],["result",["async"]]]],[11,"close","","",83,[[["self"]],["result",["async"]]]],[11,"start_send","","",84,N],[11,"poll_complete","","",84,[[["self"]],["result",["async"]]]],[11,"close","","",84,[[["self"]],["result",["async"]]]],[11,"start_send","","",85,N],[11,"poll_complete","","",85,[[["self"]],["result",["async"]]]],[11,"close","","",85,[[["self"]],["result",["async"]]]],[11,"start_send","","",86,N],[11,"poll_complete","","",86,[[["self"]],["result",["async"]]]],[11,"close","","",86,[[["self"]],["result",["async"]]]],[11,"start_send","","",87,N],[11,"poll_complete","","",87,[[["self"]],["result",["async"]]]],[11,"close","","",87,[[["self"]],["result",["async"]]]],[11,"start_send","","",88,N],[11,"poll_complete","","",88,[[["self"]],["result",["async"]]]],[11,"close","","",88,[[["self"]],["result",["async"]]]],[11,"start_send","","",89,N],[11,"poll_complete","","",89,[[["self"]],["result",["async"]]]],[11,"close","","",89,[[["self"]],["result",["async"]]]],[11,"start_send","","",90,N],[11,"poll_complete","","",90,[[["self"]],["result",["async"]]]],[11,"close","","",90,[[["self"]],["result",["async"]]]],[11,"start_send","","",91,N],[11,"poll_complete","","",91,[[["self"]],["result",["async"]]]],[11,"close","","",91,[[["self"]],["result",["async"]]]],[11,"start_send","","",92,N],[11,"poll_complete","","",92,[[["self"]],["result",["async"]]]],[11,"close","","",92,[[["self"]],["result",["async"]]]],[11,"start_send","","",93,N],[11,"poll_complete","","",93,[[["self"]],["result",["async"]]]],[11,"close","","",93,[[["self"]],["result",["async"]]]],[11,"start_send","","",94,N],[11,"poll_complete","","",94,[[["self"]],["result",["async"]]]],[11,"close","","",94,[[["self"]],["result",["async"]]]],[11,"clone","tokio::prelude::future","",24,[[["self"]],["executeerrorkind"]]],[11,"clone","","",95,[[["self"]],["shareditem"]]],[11,"clone","","",96,[[["self"]],["sharederror"]]],[11,"clone","tokio::prelude","",32,[[["self"]],["asyncsink"]]],[11,"clone","tokio::prelude::task","",97,[[["self"]],["task"]]],[11,"clone","","",98,[[["self"]],["unparkevent"]]],[11,"clone","tokio::prelude","",31,[[["self"]],["async"]]],[11,"clone","tokio::prelude::task","",99,[[["self"]],["taskrc"]]],[11,"clone","tokio::prelude::future","",44,[[["self"]],["shared"]]],[11,"clone","","",57,[[["self"]],["futureresult"]]],[11,"fmt","tokio::prelude::stream","",80,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",86,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::prelude::future","",48,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",56,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::prelude::task","",100,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::prelude::future","",42,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",38,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::prelude::stream","",92,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",101,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::prelude::future","",69,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",45,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::prelude::task","",97,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::prelude::stream","",102,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::prelude::future","",25,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::prelude::stream","",103,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::prelude::task","",37,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::prelude::stream","",94,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",104,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",81,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",78,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",105,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::prelude::future","",59,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",64,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::prelude::stream","",29,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",84,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::prelude::future","",41,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::prelude::stream","",68,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::prelude::future","",65,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::prelude::stream","",90,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::prelude::stream::futures_unordered","",73,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::prelude::future","",106,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::prelude::stream","",40,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",107,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::prelude","",31,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::prelude::stream","",28,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::prelude::future","",66,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::prelude::stream","",72,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",108,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",67,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",87,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",109,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::prelude::future","",61,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::prelude::stream","",110,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",111,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::prelude::future","",24,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",62,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::prelude::task","",98,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::prelude::stream","",74,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::prelude::future","",57,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::prelude::stream","",112,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",82,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::prelude::future","",95,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",52,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::prelude::stream::futures_unordered","",113,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::prelude::future","",51,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::prelude::stream","",71,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",79,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::prelude::future","",26,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::prelude::stream","",114,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::prelude::future","",46,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::prelude","",32,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::prelude::future","",44,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",43,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::prelude::stream","",115,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",116,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",93,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",117,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",91,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",89,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::prelude::future","",60,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::prelude::stream","",63,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",54,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",85,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",83,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::prelude::future","",118,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",96,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::prelude::stream","",75,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::prelude::task","",99,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::prelude::stream","",53,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::prelude::future","",55,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::prelude::task","",119,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::prelude::future","",39,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",120,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::prelude::stream","",76,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::prelude::future","",58,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::prelude::stream","",77,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::prelude::future","",47,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::prelude::stream","",121,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",49,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",88,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",122,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",123,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::prelude::future","",50,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::prelude::task","",124,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::prelude::future","",70,[[["self"],["formatter"]],["result",["error"]]]],[11,"poll","tokio::prelude::stream","",86,[[["self"]],["result",["async"]]]],[11,"poll","","",78,[[["self"]],["result",["async"]]]],[11,"poll","","",112,[[["self"]],["result",["async"]]]],[11,"poll","","",74,[[["self"]],["result",["async"]]]],[11,"poll","","",122,[[["self"]],["result",["async"]]]],[11,"poll","","",92,[[["self"]],["result",["async"]]]],[11,"poll","tokio::prelude::future","",118,[[["self"]],["result",["async"]]]],[11,"poll","tokio::prelude::stream","",110,[[["self"]],["result",["async"]]]],[11,"poll","","",83,[[["self"]],["result",["async"]]]],[11,"poll","","",80,[[["self"]],["result",["async"]]]],[11,"poll","","",108,[[["self"]],["result",["async"]]]],[11,"poll","","",90,[[["self"]],["result",["async"]]]],[11,"poll","","",121,[[["self"]],["result",["async"]]]],[11,"poll","","",103,[[["self"]],["result",["async"]]]],[11,"poll","","",77,[[["self"]],["result",["async"]]]],[11,"poll","","",115,[[["self"]],["result",["async"]]]],[11,"poll","","",116,[[["self"]],["result",["async"]]]],[11,"poll","","",82,[[["self"]],["result",["async"]]]],[11,"poll","","",93,[[["self"]],["result",["async"]]]],[11,"poll","","",123,[[["self"]],["result",["async"]]]],[11,"poll","","",87,[[["self"]],["result",["async"]]]],[11,"poll","","",102,[[["self"]],["result",["async"]]]],[11,"poll","","",88,[[["self"]],["result",["async"]]]],[11,"poll","","",114,[[["self"]],["result",["async"]]]],[11,"poll","","",72,[[["self"]],["result",["async"]]]],[11,"poll","tokio::prelude::future","",120,[[["self"]],["result",["async"]]]],[11,"poll","tokio::prelude::stream::futures_unordered","",73,[[["self"]],["result",["async"]]]],[11,"poll","tokio::prelude::stream","",101,[[["self"]],["result",["async"]]]],[11,"poll","","",89,[[["self"]],["result",["async"]]]],[11,"poll","","",81,[[["self"]],["result",["async"]]]],[11,"poll","","",107,[[["self"]],["result",["async"]]]],[11,"poll","","",105,[[["self"]],["result",["async"]]]],[11,"poll","","",91,[[["self"]],["result",["async"]]]],[11,"poll","","",117,[[["self"]],["result",["async"]]]],[11,"poll","","",85,[[["self"]],["result",["async"]]]],[11,"poll","","",94,[[["self"]],["result",["async"]]]],[11,"poll","","",84,[[["self"]],["result",["async"]]]],[11,"poll","","",79,[[["self"]],["result",["async"]]]],[11,"poll","","",76,[[["self"]],["result",["async"]]]],[11,"next","tokio::prelude::stream::futures_unordered","",113,[[["self"]],["option"]]],[11,"size_hint","","",113,N],[11,"next","tokio::prelude::stream","",104,[[["self"]],["option"]]],[11,"eq","tokio::prelude","",32,[[["self"],["asyncsink"]],["bool"]]],[11,"ne","","",32,[[["self"],["asyncsink"]],["bool"]]],[11,"eq","","",31,[[["self"],["async"]],["bool"]]],[11,"ne","","",31,[[["self"],["async"]],["bool"]]],[11,"eq","tokio::prelude::future","",24,[[["self"],["executeerrorkind"]],["bool"]]],[11,"fmt","tokio::prelude::stream","",111,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",28,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::prelude::future","",96,[[["self"],["formatter"]],["result",["error"]]]],[11,"description","","",96,[[["self"]],["str"]]],[11,"cause","","",96,[[["self"]],["option",["error"]]]],[11,"description","tokio::prelude::stream","",111,[[["self"]],["str"]]],[11,"description","","",28,[[["self"]],["str"]]],[11,"from","tokio::prelude::future","",57,[[["result"]],["futureresult"]]],[11,"from","tokio::prelude","",31,[[["t"]],["async"]]],[11,"deref","tokio::prelude::future","",96,[[["self"]],["e"]]],[11,"deref","","",95,[[["self"]],["t"]]],[11,"drop","tokio::prelude::stream::futures_unordered","",73,N],[11,"drop","tokio::prelude::future","",44,N],[11,"clone","tokio::runtime::current_thread","",125,[[["self"]],["taskexecutor"]]],[11,"fmt","","",125,[[["self"],["formatter"]],["result",["error"]]]],[11,"spawn","","",125,[[["self"],["box",["future"]]],["result",["spawnerror"]]]],[11,"execute","","",125,[[["self"],["f"]],["result",["executeerror"]]]],[11,"clone","tokio::executor","",126,[[["self"]],["defaultexecutor"]]],[11,"fmt","","",127,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",126,[[["self"],["formatter"]],["result",["error"]]]],[11,"spawn","","",126,[[["self"],["box",["future"]]],["result",["spawnerror"]]]],[11,"status","","",126,[[["self"]],["result",["spawnerror"]]]],[11,"description","","",127,[[["self"]],["str"]]],[11,"execute","","",126,[[["self"],["t"]],["result",["executeerror"]]]],[11,"fmt","","",127,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::io","",128,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::codec","",129,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::io","",130,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",131,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",132,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",133,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::codec","",134,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::io","",135,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",136,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",137,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::codec","",138,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::io","",139,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::codec","",14,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::io","",140,[[["self"],["formatter"]],["result",["error"]]]],[11,"write","","",140,N],[11,"flush","","",140,[[["self"]],["result",["error"]]]],[11,"shutdown","","",140,[[["self"]],["result",["async","error"]]]],[11,"write_buf","","",140,[[["self"],["b"]],["result",["async","error"]]]],[11,"read","","",132,N],[11,"read_buf","","",132,[[["self"],["b"]],["result",["async","error"]]]],[11,"poll","tokio::codec","",134,[[["self"]],["result",["async"]]]],[11,"poll","","",138,[[["self"]],["result",["async"]]]],[11,"poll","","",129,[[["self"]],["result",["async"]]]],[11,"poll","tokio::io","",137,[[["self"]],["result",["async","error"]]]],[11,"poll","","",131,[[["self"]],["result",["async","error"]]]],[11,"poll","","",139,[[["self"]],["result",["async","error"]]]],[11,"poll","","",136,[[["self"]],["result",["async","error"]]]],[11,"poll","","",133,[[["self"]],["result",["async","error"]]]],[11,"poll","","",128,[[["self"]],["result",["async","error"]]]],[11,"poll","","",135,[[["self"]],["result",["async","error"]]]],[11,"poll","","",130,[[["self"]],["result",["async","error"]]]],[11,"start_send","tokio::codec","",138,N],[11,"poll_complete","","",138,[[["self"]],["result",["async"]]]],[11,"close","","",138,[[["self"]],["result",["async"]]]],[11,"start_send","","",129,N],[11,"poll_complete","","",129,[[["self"]],["result",["async"]]]],[11,"close","","",129,[[["self"]],["result",["async"]]]],[11,"start_send","","",134,N],[11,"poll_complete","","",134,[[["self"]],["result",["async"]]]],[11,"close","","",134,[[["self"]],["result",["async"]]]],[11,"clone","","",141,[[["self"]],["linescodec"]]],[11,"clone","","",142,[[["self"]],["bytescodec"]]],[11,"fmt","","",141,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",142,[[["self"],["formatter"]],["result",["error"]]]],[11,"partial_cmp","","",142,[[["self"],["bytescodec"]],["option",["ordering"]]]],[11,"lt","","",142,[[["self"],["bytescodec"]],["bool"]]],[11,"le","","",142,[[["self"],["bytescodec"]],["bool"]]],[11,"gt","","",142,[[["self"],["bytescodec"]],["bool"]]],[11,"ge","","",142,[[["self"],["bytescodec"]],["bool"]]],[11,"partial_cmp","","",141,[[["self"],["linescodec"]],["option",["ordering"]]]],[11,"lt","","",141,[[["self"],["linescodec"]],["bool"]]],[11,"le","","",141,[[["self"],["linescodec"]],["bool"]]],[11,"gt","","",141,[[["self"],["linescodec"]],["bool"]]],[11,"ge","","",141,[[["self"],["linescodec"]],["bool"]]],[11,"cmp","","",141,[[["self"],["linescodec"]],["ordering"]]],[11,"cmp","","",142,[[["self"],["bytescodec"]],["ordering"]]],[11,"hash","","",141,N],[11,"hash","","",142,N],[11,"decode","","",141,[[["self"],["bytesmut"]],["result",["option","error"]]]],[11,"decode_eof","","",141,[[["self"],["bytesmut"]],["result",["option","error"]]]],[11,"decode","","",142,[[["self"],["bytesmut"]],["result",["option","error"]]]],[11,"encode","","",141,[[["self"],["string"],["bytesmut"]],["result",["error"]]]],[11,"encode","","",142,[[["self"],["bytes"],["bytesmut"]],["result",["error"]]]],[11,"eq","","",141,[[["self"],["linescodec"]],["bool"]]],[11,"ne","","",141,[[["self"],["linescodec"]],["bool"]]],[11,"eq","","",142,[[["self"],["bytescodec"]],["bool"]]],[11,"ne","","",142,[[["self"],["bytescodec"]],["bool"]]],[11,"clone","tokio::fs","",143,[[["self"]],["openoptions"]]],[11,"fmt","","",144,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::fs::file","",145,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::io","",146,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::fs::file","",147,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",148,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::fs::os::unix","",149,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::io","",150,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::fs::file","",151,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::io","",152,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::fs","",143,[[["self"],["formatter"]],["result",["error"]]]],[11,"drop","","",144,N],[11,"write","tokio::io","",146,N],[11,"flush","","",146,[[["self"]],["result",["error"]]]],[11,"write","tokio::fs","",144,N],[11,"flush","","",144,[[["self"]],["result",["error"]]]],[11,"write","tokio::io","",152,N],[11,"flush","","",152,[[["self"]],["result",["error"]]]],[11,"read","","",150,N],[11,"read","tokio::fs","",144,N],[11,"poll","tokio::fs::file","",148,[[["self"]],["result",["async"]]]],[11,"poll","","",145,[[["self"]],["result",["async"]]]],[11,"poll","","",151,[[["self"]],["result",["async"]]]],[11,"poll","","",147,[[["self"]],["result",["async"]]]],[11,"poll","tokio::fs::os::unix","",149,[[["self"]],["result",["async"]]]],[11,"from","tokio::fs","",143,[[["openoptions"]],["openoptions"]]],[11,"shutdown","tokio::io","",146,[[["self"]],["result",["async","error"]]]],[11,"shutdown","","",152,[[["self"]],["result",["async","error"]]]],[11,"shutdown","tokio::fs","",144,[[["self"]],["result",["async","error"]]]],[11,"prepare_uninitialized_buffer","tokio::io","",150,N],[11,"prepare_uninitialized_buffer","tokio::fs","",144,N],[11,"from","tokio::io","",36,[[["error"]],["error"]]],[11,"shutdown","tokio::reactor","",153,[[["self"]],["result",["async","error"]]]],[11,"clone","","",154,[[["self"]],["handle"]]],[11,"fmt","","",154,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",155,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",156,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",157,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",153,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",158,[[["self"],["formatter"]],["result",["error"]]]],[11,"drop","","",155,N],[11,"drop","","",153,N],[11,"default","","Returns a \"default\" handle, i.e., a handle that lazily binds to a reactor.",154,[[],["handle"]]],[11,"write","","",153,N],[11,"flush","","",153,[[["self"]],["result",["error"]]]],[11,"read","","",153,N],[11,"unpark","","",154,N],[11,"unpark","","",156,N],[11,"park","","",156,[[["self"]],["result",["error"]]]],[11,"park_timeout","","",156,[[["self"],["duration"]],["result",["error"]]]],[11,"fmt","tokio::timer","",159,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",160,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::timer::delay_queue","",161,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::timer","",162,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::timer::timeout","",163,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",164,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::timer","",165,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::timer::delay_queue","",166,[[["self"],["formatter"]],["result",["error"]]]],[11,"description","tokio::timer","",165,[[["self"]],["str"]]],[11,"description","tokio::timer::timeout","",164,[[["self"]],["str"]]],[11,"poll","","",163,[[["self"]],["result",["async"]]]],[11,"poll","tokio::timer","",162,[[["self"]],["result",["async"]]]],[11,"poll","","",159,[[["self"]],["result",["async","error"]]]],[11,"poll","tokio::timer::timeout","",163,[[["self"]],["result",["async"]]]],[11,"poll","tokio::timer","",160,[[["self"]],["result",["async"]]]],[11,"fmt","","",165,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::timer::timeout","",164,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","tokio::net::tcp","",167,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",168,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",169,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",170,[[["self"],["formatter"]],["result",["error"]]]],[11,"as_raw_fd","","",168,[[["self"]],["i32"]]],[11,"as_raw_fd","","",167,[[["self"]],["i32"]]],[11,"write","","",168,N],[11,"flush","","",168,[[["self"]],["result",["error"]]]],[11,"read","","",168,N],[11,"poll","","",169,[[["self"]],["result",["async","error"]]]],[11,"poll","","",170,[[["self"]],["result",["async","error"]]]],[11,"shutdown","","",168,[[["self"]],["result",["async","error"]]]],[11,"write_buf","","",168,[[["self"],["b"]],["result",["async","error"]]]],[11,"prepare_uninitialized_buffer","","",168,N],[11,"read_buf","","",168,[[["self"],["b"]],["result",["async","error"]]]],[11,"fmt","tokio::net::udp","",171,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",172,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",173,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",174,[[["self"],["formatter"]],["result",["error"]]]],[11,"as_raw_fd","","",171,[[["self"]],["i32"]]],[11,"poll","","",172,[[["self"]],["result",["async"]]]],[11,"poll","","",173,[[["self"]],["result",["async","error"]]]],[11,"poll","","",174,[[["self"]],["result",["async","error"]]]],[11,"start_send","","",172,N],[11,"poll_complete","","",172,[[["self"]],["result",["async"]]]],[11,"close","","",172,[[["self"]],["result",["async"]]]],[11,"clone","tokio::net::unix","",2,[[["self"]],["ucred"]]],[11,"fmt","","",175,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",176,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",177,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",178,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",179,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",180,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",181,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result",["error"]]]],[11,"as_raw_fd","","",177,[[["self"]],["i32"]]],[11,"as_raw_fd","","",180,[[["self"]],["i32"]]],[11,"as_raw_fd","","",178,[[["self"]],["i32"]]],[11,"write","","",178,N],[11,"flush","","",178,[[["self"]],["result",["error"]]]],[11,"shutdown","","",178,[[["self"]],["result",["async","error"]]]],[11,"write_buf","","",178,[[["self"],["b"]],["result",["async","error"]]]],[11,"read","","",178,N],[11,"prepare_uninitialized_buffer","","",178,N],[11,"read_buf","","",178,[[["self"],["b"]],["result",["async","error"]]]],[11,"hash","","",2,N],[11,"poll","","",179,[[["self"]],["result",["async","error"]]]],[11,"poll","","",176,[[["self"]],["result",["async"]]]],[11,"poll","","",181,[[["self"]],["result",["async"]]]],[11,"poll","","",175,[[["self"]],["result",["async","error"]]]],[11,"eq","","",2,[[["self"],["ucred"]],["bool"]]],[11,"ne","","",2,[[["self"],["ucred"]],["bool"]]],[11,"current","tokio::executor","Returns a handle to the default executor for the current context.",126,[[],["defaultexecutor"]]],[11,"shutdown","","Return a new `SpawnError` reflecting a shutdown executor failure.",127,[[],["spawnerror"]]],[11,"at_capacity","","Return a new `SpawnError` reflecting an executor at capacity failure.",127,[[],["spawnerror"]]],[11,"is_shutdown","","Returns `true` if the error reflects a shutdown executor failure.",127,[[["self"]],["bool"]]],[11,"is_at_capacity","","Returns `true` if the error reflects an executor at capacity failure.",127,[[["self"]],["bool"]]],[11,"current","tokio::runtime::current_thread","Returns an executor that executes futures on the current thread.",125,[[],["taskexecutor"]]],[11,"spawn_local","","Spawn a future onto the current `CurrentThread` instance.",125,[[["self"],["box",["future"]]],["result",["spawnerror"]]]],[11,"open","tokio::fs","Attempts to open a file in read-only mode.",144,[[["p"]],["openfuture"]]],[11,"create","","Opens a file in write-only mode.",144,[[["p"]],["createfuture"]]],[11,"poll_seek","","Seek to an offset, in bytes, in a stream.",144,[[["self"],["seekfrom"]],["result",["async","error"]]]],[11,"seek","","Seek to an offset, in bytes, in a stream.",144,[[["self"],["seekfrom"]],["seekfuture"]]],[11,"poll_sync_all","","Attempts to sync all OS-internal metadata to disk.",144,[[["self"]],["result",["async","error"]]]],[11,"poll_sync_data","","This function is similar to `poll_sync_all`, except that it may not synchronize file metadata to the filesystem.",144,[[["self"]],["result",["async","error"]]]],[11,"poll_set_len","","Truncates or extends the underlying file, updating the size of this file to become size.",144,[[["self"],["u64"]],["result",["async","error"]]]],[11,"metadata","","Queries metadata about the underlying file.",144,[[["self"]],["metadatafuture"]]],[11,"poll_metadata","","Queries metadata about the underlying file.",144,[[["self"]],["result",["async","error"]]]],[11,"poll_try_clone","","Create a new `File` instance that shares the same underlying file handle as the existing `File` instance. Reads, writes, and seeks will affect both File instances simultaneously.",144,[[["self"]],["result",["async","error"]]]],[11,"poll_set_permissions","","Changes the permissions on the underlying file.",144,[[["self"],["permissions"]],["result",["async","error"]]]],[11,"into_std","","Destructures the `tokio_fs::File` into a [`std::fs::File`][std].",144,[[["self"]],["file"]]],[11,"new","","Creates a blank new set of options ready for configuration.",143,[[],["openoptions"]]],[11,"read","","See the underlying [`read`] call for details.",143,[[["self"],["bool"]],["openoptions"]]],[11,"write","","See the underlying [`write`] call for details.",143,[[["self"],["bool"]],["openoptions"]]],[11,"append","","See the underlying [`append`] call for details.",143,[[["self"],["bool"]],["openoptions"]]],[11,"truncate","","See the underlying [`truncate`] call for details.",143,[[["self"],["bool"]],["openoptions"]]],[11,"create","","See the underlying [`create`] call for details.",143,[[["self"],["bool"]],["openoptions"]]],[11,"create_new","","See the underlying [`create_new`] call for details.",143,[[["self"],["bool"]],["openoptions"]]],[11,"open","","Opens a file at `path` with the options specified by `self`.",143,[[["self"],["p"]],["openfuture"]]],[11,"bind","tokio::net::tcp","Create a new TCP listener associated with this event loop.",167,[[["socketaddr"]],["result",["tcplistener","error"]]]],[11,"poll_accept","","Attempt to accept a connection and create a new connected `TcpStream` if successful.",167,[[["self"]],["result",["async","error"]]]],[11,"poll_accept_std","","Attempt to accept a connection and create a new connected `TcpStream` if successful.",167,[[["self"]],["result",["async","error"]]]],[11,"from_std","","Create a new TCP listener from the standard library's TCP listener.",167,[[["tcplistener"],["handle"]],["result",["tcplistener","error"]]]],[11,"local_addr","","Returns the local address that this listener is bound to.",167,[[["self"]],["result",["socketaddr","error"]]]],[11,"incoming","","Consumes this listener, returning a stream of the sockets this listener accepts.",167,[[["self"]],["incoming"]]],[11,"ttl","","Gets the value of the `IP_TTL` option for this socket.",167,[[["self"]],["result",["u32","error"]]]],[11,"set_ttl","","Sets the value for the `IP_TTL` option on this socket.",167,[[["self"],["u32"]],["result",["error"]]]],[11,"connect","","Create a new TCP stream connected to the specified address.",168,[[["socketaddr"]],["connectfuture"]]],[11,"from_std","","Create a new `TcpStream` from a `net::TcpStream`.",168,[[["tcpstream"],["handle"]],["result",["tcpstream","error"]]]],[11,"connect_std","","Creates a new `TcpStream` from the pending socket inside the given `std::net::TcpStream`, connecting it to the address specified.",168,[[["tcpstream"],["socketaddr"],["handle"]],["connectfuture"]]],[11,"poll_read_ready","","Check the TCP stream's read readiness state.",168,[[["self"],["ready"]],["result",["async","error"]]]],[11,"poll_write_ready","","Check the TCP stream's write readiness state.",168,[[["self"]],["result",["async","error"]]]],[11,"local_addr","","Returns the local address that this stream is bound to.",168,[[["self"]],["result",["socketaddr","error"]]]],[11,"peer_addr","","Returns the remote address that this stream is connected to.",168,[[["self"]],["result",["socketaddr","error"]]]],[11,"poll_peek","","Receives data on the socket from the remote address to which it is connected, without removing that data from the queue. On success, returns the number of bytes peeked.",168,N],[11,"shutdown","","Shuts down the read, write, or both halves of this connection.",168,[[["self"],["shutdown"]],["result",["error"]]]],[11,"nodelay","","Gets the value of the `TCP_NODELAY` option on this socket.",168,[[["self"]],["result",["bool","error"]]]],[11,"set_nodelay","","Sets the value of the `TCP_NODELAY` option on this socket.",168,[[["self"],["bool"]],["result",["error"]]]],[11,"recv_buffer_size","","Gets the value of the `SO_RCVBUF` option on this socket.",168,[[["self"]],["result",["usize","error"]]]],[11,"set_recv_buffer_size","","Sets the value of the `SO_RCVBUF` option on this socket.",168,[[["self"],["usize"]],["result",["error"]]]],[11,"send_buffer_size","","Gets the value of the `SO_SNDBUF` option on this socket.",168,[[["self"]],["result",["usize","error"]]]],[11,"set_send_buffer_size","","Sets the value of the `SO_SNDBUF` option on this socket.",168,[[["self"],["usize"]],["result",["error"]]]],[11,"keepalive","","Returns whether keepalive messages are enabled on this socket, and if so the duration of time between them.",168,[[["self"]],["result",["option","error"]]]],[11,"set_keepalive","","Sets whether keepalive messages are enabled to be sent on this socket.",168,[[["self"],["option",["duration"]]],["result",["error"]]]],[11,"ttl","","Gets the value of the `IP_TTL` option for this socket.",168,[[["self"]],["result",["u32","error"]]]],[11,"set_ttl","","Sets the value for the `IP_TTL` option on this socket.",168,[[["self"],["u32"]],["result",["error"]]]],[11,"linger","","Reads the linger duration for this socket by getting the `SO_LINGER` option.",168,[[["self"]],["result",["option","error"]]]],[11,"set_linger","","Sets the linger duration of this socket by setting the `SO_LINGER` option.",168,[[["self"],["option",["duration"]]],["result",["error"]]]],[11,"try_clone","","Creates a new independently owned handle to the underlying socket.",168,[[["self"]],["result",["tcpstream","error"]]]],[11,"new","tokio::net::udp","Create a new `UdpFramed` backed by the given socket and codec.",172,[[["udpsocket"],["c"]],["udpframed"]]],[11,"get_ref","","Returns a reference to the underlying I/O stream wrapped by `Framed`.",172,[[["self"]],["udpsocket"]]],[11,"get_mut","","Returns a mutable reference to the underlying I/O stream wrapped by `Framed`.",172,[[["self"]],["udpsocket"]]],[11,"into_inner","","Consumes the `Framed`, returning its underlying I/O stream.",172,[[["self"]],["udpsocket"]]],[11,"bind","","This function will create a new UDP socket and attempt to bind it to the `addr` provided.",171,[[["socketaddr"]],["result",["udpsocket","error"]]]],[11,"from_std","","Creates a new `UdpSocket` from the previously bound socket provided.",171,[[["udpsocket"],["handle"]],["result",["udpsocket","error"]]]],[11,"local_addr","","Returns the local address that this socket is bound to.",171,[[["self"]],["result",["socketaddr","error"]]]],[11,"connect","","Connects the UDP socket setting the default destination for send() and limiting packets that are read via recv from the address specified in `addr`.",171,[[["self"],["socketaddr"]],["result",["error"]]]],[11,"poll_send","","Sends data on the socket to the remote address to which it is connected.",171,N],[11,"poll_recv","","Receives a single datagram message on the socket from the remote address to which it is connected. On success, returns the number of bytes read.",171,N],[11,"poll_send_to","","Sends data on the socket to the given address. On success, returns the number of bytes written.",171,N],[11,"send_dgram","","Creates a future that will write the entire contents of the buffer `buf` provided as a datagram to this socket.",171,[[["self"],["t"],["socketaddr"]],["senddgram"]]],[11,"poll_recv_from","","Receives data from the socket. On success, returns the number of bytes read and the address from whence the data came.",171,N],[11,"recv_dgram","","Creates a future that receive a datagram to be written to the buffer provided.",171,[[["self"],["t"]],["recvdgram"]]],[11,"poll_read_ready","","Check the UDP socket's read readiness state.",171,[[["self"],["ready"]],["result",["async","error"]]]],[11,"poll_write_ready","","Check the UDP socket's write readiness state.",171,[[["self"]],["result",["async","error"]]]],[11,"broadcast","","Gets the value of the `SO_BROADCAST` option for this socket.",171,[[["self"]],["result",["bool","error"]]]],[11,"set_broadcast","","Sets the value of the `SO_BROADCAST` option for this socket.",171,[[["self"],["bool"]],["result",["error"]]]],[11,"multicast_loop_v4","","Gets the value of the `IP_MULTICAST_LOOP` option for this socket.",171,[[["self"]],["result",["bool","error"]]]],[11,"set_multicast_loop_v4","","Sets the value of the `IP_MULTICAST_LOOP` option for this socket.",171,[[["self"],["bool"]],["result",["error"]]]],[11,"multicast_ttl_v4","","Gets the value of the `IP_MULTICAST_TTL` option for this socket.",171,[[["self"]],["result",["u32","error"]]]],[11,"set_multicast_ttl_v4","","Sets the value of the `IP_MULTICAST_TTL` option for this socket.",171,[[["self"],["u32"]],["result",["error"]]]],[11,"multicast_loop_v6","","Gets the value of the `IPV6_MULTICAST_LOOP` option for this socket.",171,[[["self"]],["result",["bool","error"]]]],[11,"set_multicast_loop_v6","","Sets the value of the `IPV6_MULTICAST_LOOP` option for this socket.",171,[[["self"],["bool"]],["result",["error"]]]],[11,"ttl","","Gets the value of the `IP_TTL` option for this socket.",171,[[["self"]],["result",["u32","error"]]]],[11,"set_ttl","","Sets the value for the `IP_TTL` option on this socket.",171,[[["self"],["u32"]],["result",["error"]]]],[11,"join_multicast_v4","","Executes an operation of the `IP_ADD_MEMBERSHIP` type.",171,[[["self"],["ipv4addr"],["ipv4addr"]],["result",["error"]]]],[11,"join_multicast_v6","","Executes an operation of the `IPV6_ADD_MEMBERSHIP` type.",171,[[["self"],["ipv6addr"],["u32"]],["result",["error"]]]],[11,"leave_multicast_v4","","Executes an operation of the `IP_DROP_MEMBERSHIP` type.",171,[[["self"],["ipv4addr"],["ipv4addr"]],["result",["error"]]]],[11,"leave_multicast_v6","","Executes an operation of the `IPV6_DROP_MEMBERSHIP` type.",171,[[["self"],["ipv6addr"],["u32"]],["result",["error"]]]],[11,"bind","tokio::net::unix","Creates a new `UnixListener` bound to the specified path.",177,[[["p"]],["result",["unixlistener","error"]]]],[11,"from_std","","Consumes a `UnixListener` in the standard library and returns a nonblocking `UnixListener` from this crate.",177,[[["unixlistener"],["handle"]],["result",["unixlistener","error"]]]],[11,"local_addr","","Returns the local socket address of this listener.",177,[[["self"]],["result",["socketaddr","error"]]]],[11,"poll_read_ready","","Test whether this socket is ready to be read or not.",177,[[["self"],["ready"]],["result",["async","error"]]]],[11,"take_error","","Returns the value of the `SO_ERROR` option.",177,[[["self"]],["result",["option","error"]]]],[11,"poll_accept","","Attempt to accept a connection and create a new connected `UnixStream` if successful.",177,[[["self"]],["result",["async","error"]]]],[11,"poll_accept_std","","Attempt to accept a connection and create a new connected `UnixStream` if successful.",177,[[["self"]],["result",["async","error"]]]],[11,"incoming","","Consumes this listener, returning a stream of the sockets this listener accepts.",177,[[["self"]],["incoming"]]],[11,"connect","","Connects to the socket named by `path`.",178,[[["p"]],["connectfuture"]]],[11,"from_std","","Consumes a `UnixStream` in the standard library and returns a nonblocking `UnixStream` from this crate.",178,[[["unixstream"],["handle"]],["result",["unixstream","error"]]]],[11,"pair","","Creates an unnamed pair of connected sockets.",178,[[],["result",["error"]]]],[11,"poll_read_ready","","Test whether this socket is ready to be read or not.",178,[[["self"],["ready"]],["result",["async","error"]]]],[11,"poll_write_ready","","Test whether this socket is ready to be written to or not.",178,[[["self"]],["result",["async","error"]]]],[11,"local_addr","","Returns the socket address of the local half of this connection.",178,[[["self"]],["result",["socketaddr","error"]]]],[11,"peer_addr","","Returns the socket address of the remote half of this connection.",178,[[["self"]],["result",["socketaddr","error"]]]],[11,"peer_cred","","Returns effective credentials of the process which called `connect` or `socketpair`.",178,[[["self"]],["result",["ucred","error"]]]],[11,"take_error","","Returns the value of the `SO_ERROR` option.",178,[[["self"]],["result",["option","error"]]]],[11,"shutdown","","Shuts down the read, write, or both halves of this connection.",178,[[["self"],["shutdown"]],["result",["error"]]]],[11,"bind","","Creates a new `UnixDatagram` bound to the specified path.",180,[[["p"]],["result",["unixdatagram","error"]]]],[11,"pair","","Creates an unnamed pair of connected sockets.",180,[[],["result",["error"]]]],[11,"from_std","","Consumes a `UnixDatagram` in the standard library and returns a nonblocking `UnixDatagram` from this crate.",180,[[["unixdatagram"],["handle"]],["result",["unixdatagram","error"]]]],[11,"unbound","","Creates a new `UnixDatagram` which is not bound to any address.",180,[[],["result",["unixdatagram","error"]]]],[11,"connect","","Connects the socket to the specified address.",180,[[["self"],["p"]],["result",["error"]]]],[11,"poll_read_ready","","Test whether this socket is ready to be read or not.",180,[[["self"],["ready"]],["result",["async","error"]]]],[11,"poll_write_ready","","Test whether this socket is ready to be written to or not.",180,[[["self"]],["result",["async","error"]]]],[11,"local_addr","","Returns the local address that this socket is bound to.",180,[[["self"]],["result",["socketaddr","error"]]]],[11,"peer_addr","","Returns the address of this socket's peer.",180,[[["self"]],["result",["socketaddr","error"]]]],[11,"poll_recv_from","","Receives data from the socket.",180,N],[11,"poll_recv","","Receives data from the socket.",180,N],[11,"recv_dgram","","Returns a future for receiving a datagram. See the documentation on RecvDgram for details.",180,[[["self"],["t"]],["recvdgram"]]],[11,"poll_send_to","","Sends data on the socket to the specified address.",180,N],[11,"poll_send","","Sends data on the socket to the socket's peer.",180,N],[11,"send_dgram","","Returns a future sending the data in buf to the socket at path.",180,[[["self"],["t"],["p"]],["senddgram"]]],[11,"take_error","","Returns the value of the `SO_ERROR` option.",180,[[["self"]],["result",["option","error"]]]],[11,"shutdown","","Shut down the read, write, or both halves of this connection.",180,[[["self"],["shutdown"]],["result",["error"]]]],[11,"new","tokio::reactor","Creates a new event loop, returning any error that happened during the creation.",156,[[],["result",["reactor","error"]]]],[11,"handle","","Returns a handle to this event loop which can be sent across threads and can be used as a proxy to the event loop itself.",156,[[["self"]],["handle"]]],[11,"set_fallback","","Configures the fallback handle to be returned from `Handle::default`.",156,[[["self"]],["result",["setfallbackerror"]]]],[11,"turn","","Performs one iteration of the event loop, blocking on waiting for events for at most `max_wait` (forever if `None`).",156,[[["self"],["option",["duration"]]],["result",["turn","error"]]]],[11,"is_idle","","Returns true if the reactor is currently idle.",156,[[["self"]],["bool"]]],[11,"background","","Run this reactor on a background thread.",156,[[["self"]],["result",["background","error"]]]],[11,"current","","Returns a handle to the current reactor.",154,[[],["handle"]]],[11,"handle","","Returns a reference to the reactor handle.",155,[[["self"]],["handle"]]],[11,"shutdown_on_idle","","Shutdown the reactor on idle.",155,[[["self"]],["shutdown"]]],[11,"shutdown_now","","Shutdown the reactor immediately",155,[[["self"]],["shutdown"]]],[11,"forget","","Run the reactor on its thread until the process terminates.",155,N],[11,"new","","Create a new `Registration`.",158,[[],["registration"]]],[11,"register","","Register the I/O resource with the default reactor.",158,[[["self"],["t"]],["result",["bool","error"]]]],[11,"deregister","","Deregister the I/O resource from the reactor it is associated with.",158,[[["self"],["t"]],["result",["error"]]]],[11,"register_with","","Register the I/O resource with the specified reactor.",158,[[["self"],["t"],["handle"]],["result",["bool","error"]]]],[11,"poll_read_ready","","Poll for events on the I/O resource's read readiness stream.",158,[[["self"]],["result",["async","error"]]]],[11,"take_read_ready","","Consume any pending read readiness event.",158,[[["self"]],["result",["option","error"]]]],[11,"poll_write_ready","","Poll for events on the I/O resource's write readiness stream.",158,[[["self"]],["result",["async","error"]]]],[11,"take_write_ready","","Consume any pending write readiness event.",158,[[["self"]],["result",["option","error"]]]],[11,"new","","Creates a new `PollEvented` associated with the default reactor.",153,[[["e"]],["pollevented"]]],[11,"new_with_handle","","Creates a new `PollEvented` associated with the specified reactor.",153,[[["e"],["handle"]],["result",["pollevented","error"]]]],[11,"get_ref","","Returns a shared reference to the underlying I/O object this readiness stream is wrapping.",153,[[["self"]],["e"]]],[11,"get_mut","","Returns a mutable reference to the underlying I/O object this readiness stream is wrapping.",153,[[["self"]],["e"]]],[11,"into_inner","","Consumes self, returning the inner I/O object",153,[[["self"]],["result",["error"]]]],[11,"poll_read_ready","","Check the I/O resource's read readiness state.",153,[[["self"],["ready"]],["result",["async","error"]]]],[11,"clear_read_ready","","Clears the I/O resource's read readiness state and registers the current task to be notified once a read readiness event is received.",153,[[["self"],["ready"]],["result",["error"]]]],[11,"poll_write_ready","","Check the I/O resource's write readiness state.",153,[[["self"]],["result",["async","error"]]]],[11,"clear_write_ready","","Resets the I/O resource's write readiness state and registers the current task to be notified once a write readiness event is received.",153,[[["self"]],["result",["error"]]]],[11,"new","tokio::timer","Create a new, empty, `DelayQueue`",159,[[],["delayqueue"]]],[11,"with_capacity_and_handle","","Create a new, empty, `DelayQueue` backed by the specified timer.",159,[[["usize"],["handle"]],["delayqueue"]]],[11,"with_capacity","","Create a new, empty, `DelayQueue` with the specified capacity.",159,[[["usize"]],["delayqueue"]]],[11,"insert_at","","Insert `value` into the queue set to expire at a specific instant in time.",159,[[["self"],["t"],["instant"]],["key"]]],[11,"insert","","Insert `value` into the queue set to expire after the requested duration elapses.",159,[[["self"],["t"],["duration"]],["key"]]],[11,"remove","","Remove the item associated with `key` from the queue.",159,[[["self"],["key"]],["expired"]]],[11,"reset_at","","Sets the delay of the item associated with `key` to expire at `when`.",159,N],[11,"reset","","Sets the delay of the item associated with `key` to expire after `timeout`.",159,N],[11,"clear","","Clears the queue, removing all items.",159,N],[11,"capacity","","Returns the number of elements the queue can hold without reallocating.",159,[[["self"]],["usize"]]],[11,"reserve","","Reserve capacity for at least `additional` more items to be queued without allocating.",159,N],[11,"is_empty","","Returns `true` if there are no items in the queue.",159,[[["self"]],["bool"]]],[11,"get_ref","tokio::timer::delay_queue","Returns a reference to the inner value.",166,[[["self"]],["t"]]],[11,"get_mut","","Returns a mutable reference to the inner value.",166,[[["self"]],["t"]]],[11,"into_inner","","Consumes `self` and returns the inner value.",166,[[["self"]],["t"]]],[11,"shutdown","tokio::timer","Create an error representing a shutdown timer.",165,[[],["error"]]],[11,"is_shutdown","","Returns `true` if the error was caused by the timer being shutdown.",165,[[["self"]],["bool"]]],[11,"at_capacity","","Create an error representing a timer at capacity.",165,[[],["error"]]],[11,"is_at_capacity","","Returns `true` if the error was caused by the timer being at capacity.",165,[[["self"]],["bool"]]],[11,"new","","Create a new `Interval` that starts at `at` and yields every `duration` interval after that.",162,[[["instant"],["duration"]],["interval"]]],[11,"new_interval","","Creates new `Interval` that yields with interval of `duration`.",162,[[["duration"]],["interval"]]],[11,"new","","Create a new `Delay` instance that elapses at `deadline`.",160,[[["instant"]],["delay"]]],[11,"deadline","","Returns the instant at which the future will complete.",160,[[["self"]],["instant"]]],[11,"is_elapsed","","Returns true if the `Delay` has elapsed",160,[[["self"]],["bool"]]],[11,"reset","","Reset the `Delay` instance to a new deadline.",160,N],[11,"new","tokio::timer::timeout","Create a new `Timeout` that allows `value` to execute for a duration of at most `timeout`.",163,[[["t"],["duration"]],["timeout"]]],[11,"get_ref","","Gets a reference to the underlying value in this timeout.",163,[[["self"]],["t"]]],[11,"get_mut","","Gets a mutable reference to the underlying value in this timeout.",163,[[["self"]],["t"]]],[11,"into_inner","","Consumes this timeout, returning the underlying value.",163,[[["self"]],["t"]]],[11,"new_at","","Create a new `Timeout` that completes when `future` completes or when `deadline` is reached.",163,[[["t"],["instant"]],["timeout"]]],[11,"inner","","Create a new `Error` representing the inner value completing with `Err`.",164,[[["t"]],["error"]]],[11,"is_inner","","Returns `true` if the error was caused by the inner value completing with `Err`.",164,[[["self"]],["bool"]]],[11,"into_inner","","Consumes `self`, returning the inner future error.",164,[[["self"]],["option"]]],[11,"elapsed","","Create a new `Error` representing the inner value not completing before the deadline is reached.",164,[[],["error"]]],[11,"is_elapsed","","Returns `true` if the error was caused by the inner value not completing before the deadline is reached.",164,[[["self"]],["bool"]]],[11,"timer","","Creates a new `Error` representing an error encountered by the timer implementation",164,[[["error"]],["error"]]],[11,"is_timer","","Returns `true` if the error was caused by the timer.",164,[[["self"]],["bool"]]],[11,"into_timer","","Consumes `self`, returning the error raised by the timer implementation.",164,[[["self"]],["option",["error"]]]],[11,"timeout","tokio::util","Creates a new future which allows `self` until `timeout`.",10,[[["self"],["duration"]],["timeout"]]],[11,"timeout","","Creates a new stream which allows `self` until `timeout`.",11,[[["self"],["duration"]],["timeout"]]],[11,"fmt","tokio::codec::length_delimited","",182,[[["self"],["formatter"]],["result"]]],[11,"clone","","",182,[[["self"]],["builder"]]],[11,"fmt","tokio::codec","",183,[[["self"],["formatter"]],["result"]]],[11,"new","","Creates a new `LengthDelimitedCodec` with the default configuration values.",183,[[],["self"]]],[11,"max_frame_length","","Returns the current max frame setting",183,[[["self"]],["usize"]]],[11,"set_max_frame_length","","Updates the max frame setting.",183,[[["self"],["usize"]]]],[11,"decode","","",183,[[["self"],["bytesmut"]],["result",["option"]]]],[11,"encode","","",183,[[["self"],["bytes"],["bytesmut"]],["result",["error"]]]],[11,"new","tokio::codec::length_delimited","Creates a new length delimited codec builder with default configuration values.",182,[[],["builder"]]],[11,"big_endian","","Read the length field as a big endian integer",182,[[["self"]],["self"]]],[11,"little_endian","","Read the length field as a little endian integer",182,[[["self"]],["self"]]],[11,"native_endian","","Read the length field as a native endian integer",182,[[["self"]],["self"]]],[11,"max_frame_length","","Sets the max frame length",182,[[["self"],["usize"]],["self"]]],[11,"length_field_length","","Sets the number of bytes used to represent the length field",182,[[["self"],["usize"]],["self"]]],[11,"length_field_offset","","Sets the number of bytes in the header before the length field",182,[[["self"],["usize"]],["self"]]],[11,"length_adjustment","","Delta between the payload length specified in the header and the real payload length",182,[[["self"],["isize"]],["self"]]],[11,"num_skip","","Sets the number of bytes to skip before reading the payload",182,[[["self"],["usize"]],["self"]]],[11,"new_codec","","Create a configured length delimited `LengthDelimitedCodec`",182,[[["self"]],["lengthdelimitedcodec"]]],[11,"new_read","","Create a configured length delimited `FramedRead`",182,[[["self"],["t"]],["framedread",["lengthdelimitedcodec"]]]],[11,"new_write","","Create a configured length delimited `FramedWrite`",182,[[["self"],["t"]],["framedwrite",["lengthdelimitedcodec"]]]],[11,"new_framed","","Create a configured length delimited `Framed`",182,[[["self"],["t"]],["framed",["lengthdelimitedcodec"]]]],[11,"fmt","","",184,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",184,[[["self"],["formatter"]],["result"]]],[11,"description","","",184,[[["self"]],["str"]]],[11,"new","tokio::codec","Provides a `Stream` and `Sink` interface for reading and writing to this `Io` object, using `Decode` and `Encode` to read and write the raw data.",134,[[["t"],["u"]],["framed"]]],[11,"from_parts","","Provides a `Stream` and `Sink` interface for reading and writing to this `Io` object, using `Decode` and `Encode` to read and write the raw data.",134,[[["framedparts"]],["framed"]]],[11,"get_ref","","Returns a reference to the underlying I/O stream wrapped by `Frame`.",134,[[["self"]],["t"]]],[11,"get_mut","","Returns a mutable reference to the underlying I/O stream wrapped by `Frame`.",134,[[["self"]],["t"]]],[11,"into_inner","","Consumes the `Frame`, returning its underlying I/O stream.",134,[[["self"]],["t"]]],[11,"into_parts","","Consumes the `Frame`, returning its underlying I/O stream, the buffer with unprocessed data, and the codec.",134,[[["self"]],["framedparts"]]],[11,"new","","Create a new, default, `FramedParts`",14,[[["t"],["u"]],["framedparts"]]],[11,"new","","Creates a new `FramedRead` with the given `decoder`.",129,[[["t"],["d"]],["framedread"]]],[11,"get_ref","","Returns a reference to the underlying I/O stream wrapped by `FramedRead`.",129,[[["self"]],["t"]]],[11,"get_mut","","Returns a mutable reference to the underlying I/O stream wrapped by `FramedRead`.",129,[[["self"]],["t"]]],[11,"into_inner","","Consumes the `FramedRead`, returning its underlying I/O stream.",129,[[["self"]],["t"]]],[11,"decoder","","Returns a reference to the underlying decoder.",129,[[["self"]],["d"]]],[11,"decoder_mut","","Returns a mutable reference to the underlying decoder.",129,[[["self"]],["d"]]],[11,"new","","Creates a new `FramedWrite` with the given `encoder`.",138,[[["t"],["e"]],["framedwrite"]]],[11,"get_ref","","Returns a reference to the underlying I/O stream wrapped by `FramedWrite`.",138,[[["self"]],["t"]]],[11,"get_mut","","Returns a mutable reference to the underlying I/O stream wrapped by `FramedWrite`.",138,[[["self"]],["t"]]],[11,"into_inner","","Consumes the `FramedWrite`, returning its underlying I/O stream.",138,[[["self"]],["t"]]],[11,"encoder","","Returns a reference to the underlying decoder.",138,[[["self"]],["e"]]],[11,"encoder_mut","","Returns a mutable reference to the underlying decoder.",138,[[["self"]],["e"]]],[11,"new","","Creates a new `BytesCodec` for shipping around raw bytes.",142,[[],["bytescodec"]]],[11,"new","","Returns a `LinesCodec` for splitting up data into lines.",141,[[],["linescodec"]]],[11,"new_with_max_length","","Returns a `LinesCodec` with a maximum line length limit.",141,[[["usize"]],["linescodec"]]],[11,"max_length","","Returns the maximum line length when decoding.",141,[[["self"]],["usize"]]],[11,"into_inner","tokio::io","Returns the underlying I/O object.",137,[[["self"]],["a"]]],[11,"new","","Creates a new I/O error from a known kind of error as well as an arbitrary error payload.",36,[[["errorkind"],["e"]],["error"]]],[11,"last_os_error","","Returns an error representing the last OS error which occurred.",36,[[],["error"]]],[11,"from_raw_os_error","","Creates a new instance of an `Error` from a particular OS error code.",36,[[["i32"]],["error"]]],[11,"raw_os_error","","Returns the OS error that this error represents (if any).",36,[[["self"]],["option",["i32"]]]],[11,"get_ref","","Returns a reference to the inner error wrapped by this error (if any).",36,[[["self"]],["option",["error"]]]],[11,"get_mut","","Returns a mutable reference to the inner error wrapped by this error (if any).",36,[[["self"]],["option",["error"]]]],[11,"into_inner","","Consumes the `Error`, returning its inner error (if any).",36,[[["self"]],["option",["box"]]]],[11,"kind","","Returns the corresponding `ErrorKind` for this error.",36,[[["self"]],["errorkind"]]],[11,"new","tokio::prelude::future","Create a new `ExecuteError`",106,[[["executeerrorkind"],["f"]],["executeerror"]]],[11,"kind","","Returns the associated reason for the error",106,[[["self"]],["executeerrorkind"]]],[11,"into_future","","Consumes self and returns the original future that was spawned.",106,[[["self"]],["f"]]],[11,"split","","Splits out the homogeneous type from an either of tuples.",26,N],[11,"is_done","","Returns whether the underlying future has finished or not.",45,[[["self"]],["bool"]]],[11,"peek","","If any clone of this `Shared` has completed execution, returns its result immediately without blocking. Otherwise, returns None without triggering the work represented by this `Shared`.",44,[[["self"]],["option",["result"]]]],[11,"new","tokio::prelude::stream::futures_unordered","Constructs a new, empty `FuturesUnordered`",73,[[],["futuresunordered"]]],[11,"len","","Returns the number of futures contained in the set.",73,[[["self"]],["usize"]]],[11,"is_empty","","Returns `true` if the set contains no futures",73,[[["self"]],["bool"]]],[11,"push","","Push a future into the set.",73,N],[11,"iter_mut","","Returns an iterator that allows modifying each future in the set.",73,[[["self"]],["itermut"]]],[11,"get_ref","tokio::prelude::stream","Acquires a reference to the underlying stream that this combinator is pulling from.",78,[[["self"]],["s"]]],[11,"get_mut","","Acquires a mutable reference to the underlying stream that this combinator is pulling from.",78,[[["self"]],["s"]]],[11,"into_inner","","Consumes this combinator, returning the underlying stream.",78,[[["self"]],["s"]]],[11,"peek","","Peek retrieves a reference to the next item in the stream.",83,[[["self"]],["result",["async"]]]],[11,"get_ref","","Acquires a reference to the underlying stream that this combinator is pulling from.",94,[[["self"]],["s"]]],[11,"get_mut","","Acquires a mutable reference to the underlying stream that this combinator is pulling from.",94,[[["self"]],["s"]]],[11,"into_inner","","Consumes this combinator, returning the underlying stream.",94,[[["self"]],["s"]]],[11,"get_ref","","Acquires a reference to the underlying stream that this combinator is pulling from.",104,[[["self"]],["s"]]],[11,"get_mut","","Acquires a mutable reference to the underlying stream that this combinator is pulling from.",104,[[["self"]],["s"]]],[11,"into_inner","","Consumes this combinator, returning the underlying stream.",104,[[["self"]],["s"]]],[11,"get_ref","","Acquires a reference to the underlying stream that this combinator is pulling from.",87,[[["self"]],["s"]]],[11,"get_mut","","Acquires a mutable reference to the underlying stream that this combinator is pulling from.",87,[[["self"]],["s"]]],[11,"into_inner","","Consumes this combinator, returning the underlying stream.",87,[[["self"]],["s"]]],[11,"get_ref","","Acquires a reference to the underlying stream that this combinator is pulling from.",85,[[["self"]],["s"]]],[11,"get_mut","","Acquires a mutable reference to the underlying stream that this combinator is pulling from.",85,[[["self"]],["s"]]],[11,"into_inner","","Consumes this combinator, returning the underlying stream.",85,[[["self"]],["s"]]],[11,"get_ref","","Acquires a reference to the underlying stream that this combinator is pulling from.",89,[[["self"]],["s"]]],[11,"get_mut","","Acquires a mutable reference to the underlying stream that this combinator is pulling from.",89,[[["self"]],["s"]]],[11,"into_inner","","Consumes this combinator, returning the underlying stream.",89,[[["self"]],["s"]]],[11,"send","","Sends a new value along this channel to the receiver.",109,[[["self"],["result"]],["futuresender"]]],[11,"get_ref","","Acquires a reference to the underlying stream that this combinator is pulling from.",84,[[["self"]],["s"]]],[11,"get_mut","","Acquires a mutable reference to the underlying stream that this combinator is pulling from.",84,[[["self"]],["s"]]],[11,"into_inner","","Consumes this combinator, returning the underlying stream.",84,[[["self"]],["s"]]],[11,"get_ref","","Acquires a reference to the underlying stream that this combinator is pulling from.",93,[[["self"]],["s"]]],[11,"get_mut","","Acquires a mutable reference to the underlying stream that this combinator is pulling from.",93,[[["self"]],["s"]]],[11,"into_inner","","Consumes this combinator, returning the underlying stream.",93,[[["self"]],["s"]]],[11,"is_done","","Returns whether the underlying stream has finished or not.",80,[[["self"]],["bool"]]],[11,"get_ref","","Acquires a reference to the underlying stream that this combinator is pulling from.",80,[[["self"]],["s"]]],[11,"get_mut","","Acquires a mutable reference to the underlying stream that this combinator is pulling from.",80,[[["self"]],["s"]]],[11,"into_inner","","Consumes this combinator, returning the underlying stream.",80,[[["self"]],["s"]]],[11,"get_ref","","Acquires a reference to the underlying stream that this combinator is pulling from.",77,[[["self"]],["s"]]],[11,"get_mut","","Acquires a mutable reference to the underlying stream that this combinator is pulling from.",77,[[["self"]],["s"]]],[11,"into_inner","","Consumes this combinator, returning the underlying stream.",77,[[["self"]],["s"]]],[11,"get_ref","","Acquires a reference to the underlying stream that this combinator is pulling from.",74,[[["self"]],["s"]]],[11,"get_mut","","Acquires a mutable reference to the underlying stream that this combinator is pulling from.",74,[[["self"]],["s"]]],[11,"into_inner","","Consumes this combinator, returning the underlying stream.",74,[[["self"]],["s"]]],[11,"get_ref","","Acquires a reference to the underlying stream that this combinator is pulling from.",90,[[["self"]],["s"]]],[11,"get_mut","","Acquires a mutable reference to the underlying stream that this combinator is pulling from.",90,[[["self"]],["s"]]],[11,"into_inner","","Consumes this combinator, returning the underlying stream.",90,[[["self"]],["s"]]],[11,"sink_ref","","Get a shared reference to the inner sink. If this combinator has already been polled to completion, None will be returned.",49,[[["self"]],["option"]]],[11,"sink_mut","","Get a mutable reference to the inner sink. If this combinator has already been polled to completion, None will be returned.",49,[[["self"]],["option"]]],[11,"stream_ref","","Get a shared reference to the inner stream. If this combinator has already been polled to completion, None will be returned.",49,[[["self"]],["option"]]],[11,"stream_mut","","Get a mutable reference to the inner stream. If this combinator has already been polled to completion, None will be returned.",49,[[["self"]],["option"]]],[11,"get_ref","","Acquires a reference to the underlying stream that this combinator is pulling from.",88,[[["self"]],["s"]]],[11,"get_mut","","Acquires a mutable reference to the underlying stream that this combinator is pulling from.",88,[[["self"]],["s"]]],[11,"into_inner","","Consumes this combinator, returning the underlying stream.",88,[[["self"]],["s"]]],[11,"get_ref","","Acquires a reference to the underlying stream that this combinator is pulling from.",82,[[["self"]],["s"]]],[11,"get_mut","","Acquires a mutable reference to the underlying stream that this combinator is pulling from.",82,[[["self"]],["s"]]],[11,"into_inner","","Consumes this combinator, returning the underlying stream.",82,[[["self"]],["s"]]],[11,"get_ref","","Acquires a reference to the underlying stream that this combinator is pulling from.",71,[[["self"]],["option"]]],[11,"get_mut","","Acquires a mutable reference to the underlying stream that this combinator is pulling from.",71,[[["self"]],["option"]]],[11,"into_inner","","Consumes this combinator, returning the underlying stream.",71,[[["self"]],["option"]]],[11,"get_ref","","Acquires a reference to the underlying stream that this combinator is pulling from.",81,[[["self"]],["s"]]],[11,"get_mut","","Acquires a mutable reference to the underlying stream that this combinator is pulling from.",81,[[["self"]],["s"]]],[11,"into_inner","","Consumes this combinator, returning the underlying stream.",81,[[["self"]],["s"]]],[11,"reunite","","Attempts to put the two \"halves\" of a split `Stream + Sink` back together. Succeeds only if the `SplitStream<S>` and `SplitSink<S>` are a matching pair originating from the same call to `Stream::split`.",75,[[["self"],["splitstream"]],["result",["reuniteerror"]]]],[11,"get_ref","","Acquires a reference to the underlying stream that this combinator is pulling from.",79,[[["self"]],["s"]]],[11,"get_mut","","Acquires a mutable reference to the underlying stream that this combinator is pulling from.",79,[[["self"]],["s"]]],[11,"into_inner","","Consumes this combinator, returning the underlying stream.",79,[[["self"]],["s"]]],[11,"get_ref","","Acquires a reference to the underlying stream that this combinator is pulling from.",76,[[["self"]],["s"]]],[11,"get_mut","","Acquires a mutable reference to the underlying stream that this combinator is pulling from.",76,[[["self"]],["s"]]],[11,"into_inner","","Consumes this combinator, returning the underlying stream.",76,[[["self"]],["s"]]],[11,"get_ref","","Acquires a reference to the underlying stream that this combinator is pulling from.",86,[[["self"]],["s"]]],[11,"get_mut","","Acquires a mutable reference to the underlying stream that this combinator is pulling from.",86,[[["self"]],["s"]]],[11,"into_inner","","Consumes this combinator, returning the underlying stream.",86,[[["self"]],["s"]]],[11,"new","","Constructs a new, empty `FuturesOrdered`",72,[[],["futuresordered"]]],[11,"len","","Returns the number of futures contained in the queue.",72,[[["self"]],["usize"]]],[11,"is_empty","","Returns `true` if the queue contains no futures",72,[[["self"]],["bool"]]],[11,"push","","Push a future into the queue.",72,N],[11,"reunite","","Attempts to put the two \"halves\" of a split `Stream + Sink` back together. Succeeds only if the `SplitStream<S>` and `SplitSink<S>` are a matching pair originating from the same call to `Stream::split`.",116,[[["self"],["splitsink"]],["result",["reuniteerror"]]]],[11,"map","tokio::prelude","Change the success value of this `Async` with the closure provided",31,[[["self"],["f"]],["async"]]],[11,"is_ready","","Returns whether this is `Async::Ready`",31,[[["self"]],["bool"]]],[11,"is_not_ready","","Returns whether this is `Async::NotReady`",31,[[["self"]],["bool"]]],[11,"map","","Change the NotReady value of this `AsyncSink` with the closure provided",32,[[["self"],["f"]],["asyncsink"]]],[11,"is_ready","","Returns whether this is `AsyncSink::Ready`",32,[[["self"]],["bool"]]],[11,"is_not_ready","","Returns whether this is `AsyncSink::NotReady`",32,[[["self"]],["bool"]]],[11,"with","tokio::prelude::task","Access this task-local key, running the provided closure with a reference to the value.",100,[[["self"],["f"]],["r"]]],[11,"run","","Actually run the task (invoking `poll` on its future) on the current thread.",119,N],[11,"new","","Construct an unpark event that will insert `id` into `set` when triggered.",98,[[["arc",["eventset"]],["usize"]],["unparkevent"]]],[11,"wait_future","","Waits for the internal future to complete, blocking this thread's execution until it does.",124,[[["self"]],["result"]]],[11,"wait_stream","","Like `wait_future`, except only waits for the next element to arrive on the underlying stream.",124,[[["self"]],["option",["result"]]]],[11,"wait_send","","Blocks the current thread until it's able to send `value` on this sink.",124,N],[11,"wait_flush","","Blocks the current thread until it's able to flush this sink.",124,[[["self"]],["result"]]],[11,"wait_close","","Blocks the current thread until it's able to close this sink.",124,[[["self"]],["result"]]],[11,"get_ref","","Get a shared reference to the object the Spawn is wrapping.",124,[[["self"]],["t"]]],[11,"get_mut","","Get a mutable reference to the object the Spawn is wrapping.",124,[[["self"]],["t"]]],[11,"into_inner","","Consume the Spawn, returning its inner object",124,[[["self"]],["t"]]],[11,"poll_future_notify","","Polls the internal future, scheduling notifications to be sent to the `notify` argument.",124,[[["self"],["n"],["usize"]],["result",["async"]]]],[11,"poll_stream_notify","","Like `poll_future_notify`, except polls the underlying stream.",124,[[["self"],["n"],["usize"]],["result",["async"]]]],[11,"start_send_notify","","Invokes the underlying `start_send` method with this task in place.",124,N],[11,"poll_flush_notify","","Invokes the underlying `poll_complete` method with this task in place.",124,[[["self"],["n"],["usize"]],["result",["async"]]]],[11,"close_notify","","Invokes the underlying `close` method with this task in place.",124,[[["self"],["n"],["usize"]],["result",["async"]]]],[11,"notify","","Indicate that the task should attempt to poll its future in a timely fashion.",97,N],[11,"is_current","","Returns `true` when called from within the context of the task.",97,[[["self"]],["bool"]]],[11,"will_notify_current","","This function is intended as a performance optimization for structures which store a `Task` internally.",97,[[["self"]],["bool"]]],[11,"new","","Create an `AtomicTask` initialized with the given `Task`",37,[[],["atomictask"]]],[11,"register","","Registers the current task to be notified on calls to `notify`.",37,N],[11,"register_task","","Registers the provided task to be notified on calls to `notify`.",37,N],[11,"notify","","Notifies the task that last called `register`.",37,N],[11,"new","","Inserts a new piece of task-local data into this task, returning a reference to it.",99,[[["a"]],["taskrc"]]],[11,"with","","Operate with a reference to the underlying data.",99,[[["self"],["f"]],["r"]]]],"paths":[[8,"Executor"],[3,"Spawn"],[3,"UCred"],[3,"Builder"],[3,"Builder"],[3,"Runtime"],[3,"Handle"],[3,"Shutdown"],[3,"TaskExecutor"],[3,"Runtime"],[8,"FutureExt"],[8,"StreamExt"],[8,"Decoder"],[8,"Encoder"],[3,"FramedParts"],[8,"AsyncRead"],[8,"AsyncWrite"],[4,"ErrorKind"],[8,"Read"],[8,"Write"],[8,"Future"],[8,"IntoFuture"],[8,"FutureFrom"],[8,"Executor"],[4,"ExecuteErrorKind"],[4,"Loop"],[4,"Either"],[8,"Stream"],[3,"ReuniteError"],[4,"MergedItem"],[8,"Sink"],[4,"Async"],[4,"AsyncSink"],[8,"Unpark"],[8,"Executor"],[8,"EventSet"],[3,"Error"],[3,"AtomicTask"],[3,"Flatten"],[3,"Select"],[3,"Collect"],[3,"LoopFn"],[3,"Join3"],[3,"Select2"],[3,"Shared"],[3,"Fuse"],[3,"Join"],[3,"AndThen"],[3,"MapErr"],[3,"Forward"],[3,"SelectAll"],[3,"CatchUnwind"],[3,"Empty"],[3,"Concat2"],[3,"FutureSender"],[3,"JoinAll"],[3,"Inspect"],[3,"Done"],[3,"Lazy"],[3,"Map"],[3,"SelectOk"],[3,"OrElse"],[3,"SelectNext"],[3,"Fold"],[3,"PollFn"],[3,"Join4"],[3,"Join5"],[3,"ForEach"],[3,"Concat"],[3,"FromErr"],[3,"Then"],[3,"StreamFuture"],[3,"FuturesOrdered"],[3,"FuturesUnordered"],[3,"Inspect"],[3,"SplitSink"],[3,"AndThen"],[3,"FilterMap"],[3,"InspectErr"],[3,"FromErr"],[3,"Fuse"],[3,"SkipWhile"],[3,"Chunks"],[3,"Peekable"],[3,"Map"],[3,"Take"],[3,"Buffered"],[3,"MapErr"],[3,"Flatten"],[3,"BufferUnordered"],[3,"Filter"],[3,"OrElse"],[3,"Then"],[3,"Skip"],[3,"TakeWhile"],[3,"SharedItem"],[3,"SharedError"],[3,"Task"],[3,"UnparkEvent"],[3,"TaskRc"],[3,"LocalKey"],[3,"Receiver"],[3,"CatchUnwind"],[3,"Chain"],[3,"Wait"],[3,"Select"],[3,"ExecuteError"],[3,"PollFn"],[3,"Merge"],[3,"Sender"],[3,"Unfold"],[3,"SendError"],[3,"IterResult"],[3,"IterMut"],[3,"IterStream"],[3,"Empty"],[3,"SplitStream"],[3,"Once"],[3,"FlattenStream"],[3,"Run"],[3,"IntoStream"],[3,"IterOk"],[3,"Zip"],[3,"Repeat"],[3,"Spawn"],[3,"TaskExecutor"],[3,"DefaultExecutor"],[3,"SpawnError"],[3,"ReadToEnd"],[3,"FramedRead"],[3,"Flush"],[3,"WriteAll"],[3,"ReadHalf"],[3,"Shutdown"],[3,"Framed"],[3,"Copy"],[3,"ReadExact"],[3,"Lines"],[3,"FramedWrite"],[3,"ReadUntil"],[3,"WriteHalf"],[3,"LinesCodec"],[3,"BytesCodec"],[3,"OpenOptions"],[3,"File"],[3,"MetadataFuture"],[3,"Stdout"],[3,"OpenFuture"],[3,"SeekFuture"],[3,"SymlinkFuture"],[3,"Stdin"],[3,"CreateFuture"],[3,"Stderr"],[3,"PollEvented2"],[3,"Handle"],[3,"Background"],[3,"Reactor"],[3,"Turn"],[3,"Registration"],[3,"DelayQueue"],[3,"Delay"],[3,"Key"],[3,"Interval"],[3,"Timeout"],[3,"Error"],[3,"Error"],[3,"Expired"],[3,"TcpListener"],[3,"TcpStream"],[3,"Incoming"],[3,"ConnectFuture"],[3,"UdpSocket"],[3,"UdpFramed"],[3,"RecvDgram"],[3,"SendDgram"],[3,"ConnectFuture"],[3,"SendDgram"],[3,"UnixListener"],[3,"UnixStream"],[3,"Incoming"],[3,"UnixDatagram"],[3,"RecvDgram"],[3,"Builder"],[3,"LengthDelimitedCodec"],[3,"FrameTooBig"]]};
searchIndex["tokio_channel"]={"doc":"Asynchronous channels.","items":[[0,"mpsc","tokio_channel","A multi-producer, single-consumer, futures-aware, FIFO queue with back pressure.",N,N],[3,"Sender","tokio_channel::mpsc","The transmission end of a channel which is used to send values.",N,N],[3,"UnboundedSender","","The transmission end of a channel which is used to send values.",N,N],[3,"Receiver","","The receiving end of a channel which implements the `Stream` trait.",N,N],[3,"SendError","","Error type for sending, used when the receiving end of a channel is dropped",N,N],[3,"TrySendError","","Error type returned from `try_send`",N,N],[5,"channel","","Creates an in-memory channel implementation of the `Stream` trait with bounded capacity.",N,N],[5,"unbounded","","Creates an in-memory channel implementation of the `Stream` trait with unbounded capacity.",N,N],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"clone","","",3,[[["self"]],["senderror"]]],[11,"eq","","",3,[[["self"],["senderror"]],["bool"]]],[11,"ne","","",3,[[["self"],["senderror"]],["bool"]]],[11,"clone","","",4,[[["self"]],["trysenderror"]]],[11,"eq","","",4,[[["self"],["trysenderror"]],["bool"]]],[11,"ne","","",4,[[["self"],["trysenderror"]],["bool"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"description","","",3,[[["self"]],["str"]]],[11,"into_inner","","Returns the message that was attempted to be sent but failed.",3,[[["self"]],["t"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"description","","",4,[[["self"]],["str"]]],[11,"is_full","","Returns true if this error is a result of the channel being full",4,[[["self"]],["bool"]]],[11,"is_disconnected","","Returns true if this error is a result of the receiver being dropped",4,[[["self"]],["bool"]]],[11,"into_inner","","Returns the message that was attempted to be sent but failed.",4,[[["self"]],["t"]]],[11,"try_send","","Attempts to send a message on this `Sender<T>` without blocking.",0,[[["self"],["t"]],["result",["trysenderror"]]]],[11,"poll_ready","","Polls the channel to determine if there is guaranteed to be capacity to send at least one item without waiting.",0,[[["self"]],["poll",["senderror"]]]],[11,"start_send","","",0,[[["self"],["t"]],["startsend",["senderror"]]]],[11,"poll_complete","","",0,[[["self"]],["poll",["senderror"]]]],[11,"close","","",0,[[["self"]],["poll",["senderror"]]]],[11,"unbounded_send","","Sends the provided message along this channel.",1,[[["self"],["t"]],["result",["senderror"]]]],[11,"start_send","","",1,[[["self"],["t"]],["startsend",["senderror"]]]],[11,"poll_complete","","",1,[[["self"]],["poll",["senderror"]]]],[11,"close","","",1,[[["self"]],["poll",["senderror"]]]],[11,"clone","","",1,[[["self"]],["unboundedsender"]]],[11,"clone","","",0,[[["self"]],["sender"]]],[11,"drop","","",0,[[["self"]]]],[11,"close","","Closes the receiving half",2,[[["self"]]]],[11,"poll","","",2,[[["self"]],["poll",["option"]]]],[11,"drop","","",2,[[["self"]]]],[0,"oneshot","tokio_channel","A one-shot, futures-aware channel",N,N],[3,"Receiver","tokio_channel::oneshot","A future representing the completion of a computation happening elsewhere in memory.",N,N],[3,"Sender","","Represents the completion half of a oneshot through which the result of a computation is signaled.",N,N],[3,"Canceled","","Error returned from a `Receiver<T>` whenever the corresponding `Sender<T>` is dropped.",N,N],[5,"channel","","Creates a new futures-aware, one-shot channel.",N,N],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",6,[[["self"],["formatter"]],["result"]]],[11,"send","","Completes this oneshot with a successful result.",6,[[["self"],["t"]],["result"]]],[11,"poll_cancel","","Polls this `Sender` half to detect whether the `Receiver` this has paired with has gone away.",6,[[["self"]],["poll"]]],[11,"is_canceled","","Tests to see whether this `Sender`'s corresponding `Receiver` has gone away.",6,[[["self"]],["bool"]]],[11,"drop","","",6,[[["self"]]]],[11,"clone","","",7,[[["self"]],["canceled"]]],[11,"eq","","",7,[[["self"],["canceled"]],["bool"]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"description","","",7,[[["self"]],["str"]]],[11,"close","","Gracefully close this receiver, preventing sending any future messages.",5,[[["self"]]]],[11,"poll","","",5,[[["self"]],["poll",["canceled"]]]],[11,"drop","","",5,[[["self"]]]]],"paths":[[3,"Sender"],[3,"UnboundedSender"],[3,"Receiver"],[3,"SendError"],[3,"TrySendError"],[3,"Receiver"],[3,"Sender"],[3,"Canceled"]]};
searchIndex["tokio_codec"]={"doc":"Utilities for encoding and decoding frames.","items":[[8,"Decoder","tokio_codec","Decoding of frames via buffers.",N,N],[16,"Item","","The type of decoded frames.",0,N],[16,"Error","","The type of unrecoverable frame decoding errors.",0,N],[10,"decode","","Attempts to decode a frame from the provided buffer of bytes.",0,[[["self"],["bytesmut"]],["result",["option"]]]],[11,"decode_eof","","A default method available to be called when there are no more bytes available to be read from the underlying I/O.",0,[[["self"],["bytesmut"]],["result",["option"]]]],[11,"framed","","Provides a `Stream` and `Sink` interface for reading and writing to this `Io` object, using `Decode` and `Encode` to read and write the raw data.",0,[[["self"],["t"]],["framed"]]],[8,"Encoder","","Trait of helper objects to write out messages as bytes, for use with `FramedWrite`.",N,N],[16,"Item","","The type of items consumed by the `Encoder`",1,N],[16,"Error","","The type of encoding errors.",1,N],[10,"encode","","Encodes a frame into the buffer provided.",1,N],[3,"Framed","","A unified `Stream` and `Sink` interface to an underlying I/O object, using the `Encoder` and `Decoder` traits to encode and decode frames.",N,N],[3,"FramedParts","","`FramedParts` contains an export of the data of a Framed transport. It can be used to construct a new `Framed` with a different codec. It contains all current buffers and the inner transport.",N,N],[12,"io","","The inner transport used to read bytes to and write bytes to",2,N],[12,"codec","","The codec",2,N],[12,"read_buf","","The buffer with read but unprocessed data.",2,N],[12,"write_buf","","A buffer with unprocessed data which are not written yet.",2,N],[3,"FramedRead","","A `Stream` of messages decoded from an `AsyncRead`.",N,N],[3,"FramedWrite","","A `Sink` of frames encoded to an `AsyncWrite`.",N,N],[3,"BytesCodec","","A simple `Codec` implementation that just ships bytes around.",N,N],[3,"LinesCodec","","A simple `Codec` implementation that splits up data into lines.",N,N],[11,"clone","","",3,[[["self"]],["bytescodec"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"eq","","",3,[[["self"],["bytescodec"]],["bool"]]],[11,"ne","","",3,[[["self"],["bytescodec"]],["bool"]]],[11,"cmp","","",3,[[["self"],["bytescodec"]],["ordering"]]],[11,"partial_cmp","","",3,[[["self"],["bytescodec"]],["option",["ordering"]]]],[11,"lt","","",3,[[["self"],["bytescodec"]],["bool"]]],[11,"le","","",3,[[["self"],["bytescodec"]],["bool"]]],[11,"gt","","",3,[[["self"],["bytescodec"]],["bool"]]],[11,"ge","","",3,[[["self"],["bytescodec"]],["bool"]]],[11,"hash","","",3,N],[11,"new","","Creates a new `BytesCodec` for shipping around raw bytes.",3,[[],["bytescodec"]]],[11,"decode","","",3,[[["self"],["bytesmut"]],["result",["option","error"]]]],[11,"encode","","",3,[[["self"],["bytes"],["bytesmut"]],["result",["error"]]]],[11,"clone","","",4,[[["self"]],["linescodec"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"eq","","",4,[[["self"],["linescodec"]],["bool"]]],[11,"ne","","",4,[[["self"],["linescodec"]],["bool"]]],[11,"cmp","","",4,[[["self"],["linescodec"]],["ordering"]]],[11,"partial_cmp","","",4,[[["self"],["linescodec"]],["option",["ordering"]]]],[11,"lt","","",4,[[["self"],["linescodec"]],["bool"]]],[11,"le","","",4,[[["self"],["linescodec"]],["bool"]]],[11,"gt","","",4,[[["self"],["linescodec"]],["bool"]]],[11,"ge","","",4,[[["self"],["linescodec"]],["bool"]]],[11,"hash","","",4,N],[11,"new","","Returns a `LinesCodec` for splitting up data into lines.",4,[[],["linescodec"]]],[11,"new_with_max_length","","Returns a `LinesCodec` with a maximum line length limit.",4,[[["usize"]],["self"]]],[11,"max_length","","Returns the maximum line length when decoding.",4,[[["self"]],["usize"]]],[11,"decode","","",4,[[["self"],["bytesmut"]],["result",["option","error"]]]],[11,"decode_eof","","",4,[[["self"],["bytesmut"]],["result",["option","error"]]]],[11,"encode","","",4,[[["self"],["string"],["bytesmut"]],["result",["error"]]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",6,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result",["error"]]]],[11,"poll","","",6,[[["self"]],["result",["async"]]]],[11,"poll","","",7,[[["self"]],["result",["async"]]]],[11,"poll","","",5,[[["self"]],["result",["async"]]]],[11,"start_send","","",7,N],[11,"poll_complete","","",7,[[["self"]],["result",["async"]]]],[11,"close","","",7,[[["self"]],["result",["async"]]]],[11,"start_send","","",5,N],[11,"poll_complete","","",5,[[["self"]],["result",["async"]]]],[11,"close","","",5,[[["self"]],["result",["async"]]]],[11,"start_send","","",6,N],[11,"poll_complete","","",6,[[["self"]],["result",["async"]]]],[11,"close","","",6,[[["self"]],["result",["async"]]]],[11,"new","","Provides a `Stream` and `Sink` interface for reading and writing to this `Io` object, using `Decode` and `Encode` to read and write the raw data.",6,[[["t"],["u"]],["framed"]]],[11,"from_parts","","Provides a `Stream` and `Sink` interface for reading and writing to this `Io` object, using `Decode` and `Encode` to read and write the raw data.",6,[[["framedparts"]],["framed"]]],[11,"get_ref","","Returns a reference to the underlying I/O stream wrapped by `Frame`.",6,[[["self"]],["t"]]],[11,"get_mut","","Returns a mutable reference to the underlying I/O stream wrapped by `Frame`.",6,[[["self"]],["t"]]],[11,"into_inner","","Consumes the `Frame`, returning its underlying I/O stream.",6,[[["self"]],["t"]]],[11,"into_parts","","Consumes the `Frame`, returning its underlying I/O stream, the buffer with unprocessed data, and the codec.",6,[[["self"]],["framedparts"]]],[11,"new","","Create a new, default, `FramedParts`",2,[[["t"],["u"]],["framedparts"]]],[11,"new","","Creates a new `FramedRead` with the given `decoder`.",5,[[["t"],["d"]],["framedread"]]],[11,"get_ref","","Returns a reference to the underlying I/O stream wrapped by `FramedRead`.",5,[[["self"]],["t"]]],[11,"get_mut","","Returns a mutable reference to the underlying I/O stream wrapped by `FramedRead`.",5,[[["self"]],["t"]]],[11,"into_inner","","Consumes the `FramedRead`, returning its underlying I/O stream.",5,[[["self"]],["t"]]],[11,"decoder","","Returns a reference to the underlying decoder.",5,[[["self"]],["d"]]],[11,"decoder_mut","","Returns a mutable reference to the underlying decoder.",5,[[["self"]],["d"]]],[11,"new","","Creates a new `FramedWrite` with the given `encoder`.",7,[[["t"],["e"]],["framedwrite"]]],[11,"get_ref","","Returns a reference to the underlying I/O stream wrapped by `FramedWrite`.",7,[[["self"]],["t"]]],[11,"get_mut","","Returns a mutable reference to the underlying I/O stream wrapped by `FramedWrite`.",7,[[["self"]],["t"]]],[11,"into_inner","","Consumes the `FramedWrite`, returning its underlying I/O stream.",7,[[["self"]],["t"]]],[11,"encoder","","Returns a reference to the underlying decoder.",7,[[["self"]],["e"]]],[11,"encoder_mut","","Returns a mutable reference to the underlying decoder.",7,[[["self"]],["e"]]]],"paths":[[8,"Decoder"],[8,"Encoder"],[3,"FramedParts"],[3,"BytesCodec"],[3,"LinesCodec"],[3,"FramedRead"],[3,"Framed"],[3,"FramedWrite"]]};
searchIndex["tokio_current_thread"]={"doc":"A single-threaded executor which executes tasks on the same thread from which they are spawned.","items":[[3,"CurrentThread","tokio_current_thread","Executes tasks on the current thread",N,N],[3,"TaskExecutor","","Executes futures on the current thread.",N,N],[3,"Turn","","Returned by the `turn` function.",N,N],[3,"Entered","","A `CurrentThread` instance bound to a supplied execution context.",N,N],[3,"RunError","","Error returned by the `run` function.",N,N],[3,"RunTimeoutError","","Error returned by the `run_timeout` function.",N,N],[3,"TurnError","","Error returned by the `turn` function.",N,N],[3,"BlockError","","Error returned by the `block_on` function.",N,N],[3,"Handle","","Handle to spawn a future on the corresponding `CurrentThread` instance",N,N],[5,"block_on_all","","Run the executor bootstrapping the execution with the provided future.",N,[[["f"]],["result"]]],[5,"spawn","","Executes a future on the current thread.",N,[[["f"]]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"clone","","",0,[[["self"]],["taskexecutor"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"has_polled","","`true` if any futures were polled at all and `false` otherwise.",1,[[["self"]],["bool"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"description","","",2,[[["self"]],["str"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"description","","",3,[[["self"]],["str"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"description","","",4,[[["self"]],["str"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"description","","",5,[[["self"]],["str"]]],[11,"new","","Create a new instance of `CurrentThread`.",6,[[],["self"]]],[11,"new_with_park","","Create a new instance of `CurrentThread` backed by the given park handle.",6,[[["p"]],["self"]]],[11,"is_idle","","Returns `true` if the executor is currently idle.",6,[[["self"]],["bool"]]],[11,"spawn","","Spawn the future on the executor.",6,[[["self"],["f"]],["self"]]],[11,"block_on","","Synchronously waits for the provided `future` to complete.",6,[[["self"],["f"]],["result",["blockerror"]]]],[11,"run","","Run the executor to completion, blocking the thread until all spawned futures have completed.",6,[[["self"]],["result",["runerror"]]]],[11,"run_timeout","","Run the executor to completion, blocking the thread until all spawned futures have completed or `duration` time has elapsed.",6,[[["self"],["duration"]],["result",["runtimeouterror"]]]],[11,"turn","","Perform a single iteration of the event loop.",6,[[["self"],["option",["duration"]]],["result",["turn","turnerror"]]]],[11,"enter","","Bind `CurrentThread` instance with an execution context.",6,[[["self"],["enter"]],["entered"]]],[11,"get_park","","Returns a reference to the underlying `Park` instance.",6,[[["self"]],["p"]]],[11,"get_park_mut","","Returns a mutable reference to the underlying `Park` instance.",6,[[["self"]],["p"]]],[11,"handle","","Get a new handle to spawn futures on the executor",6,[[["self"]],["handle"]]],[11,"drop","","",6,[[["self"]]]],[11,"spawn","","",6,[[["self"],["box",["future"]]],["result",["spawnerror"]]]],[11,"fmt","","",6,[[["self"],["formatter"]],["result"]]],[11,"spawn","","Spawn the future on the executor.",7,[[["self"],["f"]],["self"]]],[11,"block_on","","Synchronously waits for the provided `future` to complete.",7,[[["self"],["f"]],["result",["blockerror"]]]],[11,"run","","Run the executor to completion, blocking the thread until all spawned futures have completed.",7,[[["self"]],["result",["runerror"]]]],[11,"run_timeout","","Run the executor to completion, blocking the thread until all spawned futures have completed or `duration` time has elapsed.",7,[[["self"],["duration"]],["result",["runtimeouterror"]]]],[11,"turn","","Perform a single iteration of the event loop.",7,[[["self"],["option",["duration"]]],["result",["turn","turnerror"]]]],[11,"get_park","","Returns a reference to the underlying `Park` instance.",7,[[["self"]],["p"]]],[11,"get_park_mut","","Returns a mutable reference to the underlying `Park` instance.",7,[[["self"]],["p"]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"clone","","",8,[[["self"]],["handle"]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result"]]],[11,"spawn","","Spawn a future onto the `CurrentThread` instance corresponding to this handle",8,[[["self"],["f"]],["result",["spawnerror"]]]],[11,"status","","Provides a best effort hint to whether or not `spawn` will succeed.",8,[[["self"]],["result",["spawnerror"]]]],[11,"current","","Returns an executor that executes futures on the current thread.",0,[[],["taskexecutor"]]],[11,"spawn_local","","Spawn a future onto the current `CurrentThread` instance.",0,[[["self"],["box",["future"]]],["result",["spawnerror"]]]],[11,"spawn","","",0,[[["self"],["box",["future"]]],["result",["spawnerror"]]]],[11,"execute","","",0,[[["self"],["f"]],["result",["executeerror"]]]],[11,"is_timeout","","Returns `true` if the error was caused by the operation timing out.",3,[[["self"]],["bool"]]],[11,"from","","",3,[[["entererror"]],["self"]]],[11,"into_inner","","Returns the error yielded by the future being blocked on",5,[[["self"]],["option"]]],[11,"from","","",5,[[["entererror"]],["self"]]]],"paths":[[3,"TaskExecutor"],[3,"Turn"],[3,"RunError"],[3,"RunTimeoutError"],[3,"TurnError"],[3,"BlockError"],[3,"CurrentThread"],[3,"Entered"],[3,"Handle"]]};
searchIndex["tokio_executor"]={"doc":"Task execution related traits and utilities.","items":[[3,"Enter","tokio_executor","Represents an executor context.",N,N],[3,"EnterError","","An error returned by `enter` if an execution scope has already been entered.",N,N],[3,"DefaultExecutor","","Executes futures on the default executor for the current execution context.",N,N],[3,"SpawnError","","Errors returned by `Executor::spawn`.",N,N],[5,"enter","","Marks the current thread as being within the dynamic extent of an executor.",N,[[],["result",["enter","entererror"]]]],[5,"spawn","","Submits a future for execution on the default executor -- usually a threadpool.",N,[[["t"]]]],[5,"with_default","","Set the default executor for the duration of the closure",N,[[["t"],["enter"],["f"]],["r"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"description","","",0,[[["self"]],["str"]]],[11,"on_exit","","Register a callback to be invoked if and when the thread ceased to act as an executor.",1,[[["self"],["f"]]]],[11,"make_permanent","","Treat the remainder of execution on this thread as part of an executor; used mostly for thread pool worker threads.",1,[[["self"]]]],[11,"block_on","","Blocks the thread on the specified future, returning the value with which that future completes.",1,[[["self"],["f"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"drop","","",1,[[["self"]]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"clone","","",2,[[["self"]],["defaultexecutor"]]],[11,"current","","Returns a handle to the default executor for the current context.",2,[[],["defaultexecutor"]]],[11,"spawn","","",2,[[["self"],["box",["future"]]],["result",["spawnerror"]]]],[11,"status","","",2,[[["self"]],["result",["spawnerror"]]]],[11,"execute","","",2,[[["self"],["t"]],["result",["executeerror"]]]],[0,"park","","Abstraction over blocking and unblocking the current thread.",N,N],[3,"ParkThread","tokio_executor::park","Blocks the current thread using a condition variable.",N,N],[3,"ParkError","","Error returned by [`ParkThread`]",N,N],[3,"UnparkThread","","Unblocks a thread that was blocked by `ParkThread`.",N,N],[8,"Park","","Block the current thread.",N,N],[16,"Unpark","","Unpark handle type for the `Park` implementation.",3,N],[16,"Error","","Error returned by `park`",3,N],[10,"unpark","","Get a new `Unpark` handle associated with this `Park` instance.",3,N],[10,"park","","Block the current thread unless or until the token is available.",3,[[["self"]],["result"]]],[10,"park_timeout","","Park the current thread for at most `duration`.",3,[[["self"],["duration"]],["result"]]],[8,"Unpark","","Unblock a thread blocked by the associated [`Park`] instance.",N,N],[10,"unpark","","Unblock a thread that is blocked by the associated `Park` handle.",4,[[["self"]]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",6,[[["self"],["formatter"]],["result"]]],[11,"clone","","",7,[[["self"]],["unparkthread"]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"new","","Create a new `ParkThread` handle for the current thread.",5,[[],["parkthread"]]],[11,"unpark","","",5,N],[11,"park","","",5,[[["self"]],["result"]]],[11,"park_timeout","","",5,[[["self"],["duration"]],["result"]]],[11,"unpark","","",7,[[["self"]]]],[8,"Executor","tokio_executor","A value that executes futures.",N,N],[10,"spawn","","Spawns a future object to run on this executor.",8,[[["self"],["box",["future"]]],["result",["spawnerror"]]]],[11,"status","","Provides a best effort hint to whether or not `spawn` will succeed.",8,[[["self"]],["result",["spawnerror"]]]],[11,"fmt","","",9,[[["self"],["formatter"]],["result"]]],[11,"shutdown","","Return a new `SpawnError` reflecting a shutdown executor failure.",9,[[],["self"]]],[11,"at_capacity","","Return a new `SpawnError` reflecting an executor at capacity failure.",9,[[],["self"]]],[11,"is_shutdown","","Returns `true` if the error reflects a shutdown executor failure.",9,[[["self"]],["bool"]]],[11,"is_at_capacity","","Returns `true` if the error reflects an executor at capacity failure.",9,[[["self"]],["bool"]]],[11,"fmt","","",9,[[["self"],["formatter"]],["result"]]],[11,"description","","",9,[[["self"]],["str"]]]],"paths":[[3,"EnterError"],[3,"Enter"],[3,"DefaultExecutor"],[8,"Park"],[8,"Unpark"],[3,"ParkThread"],[3,"ParkError"],[3,"UnparkThread"],[8,"Executor"],[3,"SpawnError"]]};
searchIndex["tokio_fs"]={"doc":"Asynchronous file and standard stream adaptation.","items":[[3,"CreateDirFuture","tokio_fs","Future returned by `create_dir`.",N,N],[3,"CreateDirAllFuture","","Future returned by `create_dir_all`.",N,N],[3,"OpenOptions","","Options and flags which can be used to configure how a file is opened.",N,N],[3,"HardLinkFuture","","Future returned by `hard_link`.",N,N],[3,"MetadataFuture","","Future returned by `metadata`.",N,N],[3,"ReadDirFuture","","Future returned by `read_dir`.",N,N],[3,"ReadDir","","Stream of the entries in a directory.",N,N],[3,"DirEntry","","Entries returned by the [`ReadDir`] stream.",N,N],[3,"ReadLinkFuture","","Future returned by `read_link`.",N,N],[3,"RemoveDirFuture","","Future returned by `remove_dir`.",N,N],[3,"RemoveFileFuture","","Future returned by `remove_file`.",N,N],[3,"RenameFuture","","Future returned by `rename`.",N,N],[3,"SetPermissionsFuture","","Future returned by `set_permissions`.",N,N],[3,"Stdin","","A handle to the standard input stream of a process.",N,N],[3,"Stdout","","A handle to the standard output stream of a process.",N,N],[3,"Stderr","","A handle to the standard error stream of a process.",N,N],[3,"SymlinkMetadataFuture","","Future returned by `symlink_metadata`.",N,N],[5,"create_dir","","Creates a new, empty directory at the provided path",N,[[["p"]],["createdirfuture"]]],[5,"create_dir_all","","Recursively create a directory and all of its parent components if they are missing.",N,[[["p"]],["createdirallfuture"]]],[5,"hard_link","","Creates a new hard link on the filesystem.",N,[[["p"],["q"]],["hardlinkfuture"]]],[5,"metadata","","Queries the file system metadata for a path.",N,[[["p"]],["metadatafuture"]]],[5,"read_dir","","Returns a stream over the entries within a directory.",N,[[["p"]],["readdirfuture"]]],[5,"read_link","","Reads a symbolic link, returning the file that the link points to.",N,[[["p"]],["readlinkfuture"]]],[5,"remove_dir","","Removes an existing, empty directory.",N,[[["p"]],["removedirfuture"]]],[5,"remove_file","","Removes a file from the filesystem.",N,[[["p"]],["removefilefuture"]]],[5,"rename","","Rename a file or directory to a new name, replacing the original file if `to` already exists.",N,[[["p"],["q"]],["renamefuture"]]],[5,"set_permissions","","Changes the permissions found on a file or a directory.",N,[[["p"],["permissions"]],["setpermissionsfuture"]]],[5,"stdin","","Constructs a new handle to the standard input of the current process.",N,[[],["stdin"]]],[5,"stdout","","Constructs a new handle to the standard output of the current process.",N,[[],["stdout"]]],[5,"stderr","","Constructs a new handle to the standard error of the current process.",N,[[],["stderr"]]],[5,"symlink_metadata","","Queries the file system metadata for a path.",N,[[["p"]],["symlinkmetadatafuture"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"poll","","",0,[[["self"]],["poll"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"poll","","",1,[[["self"]],["poll"]]],[0,"file","","Types for working with [`File`].",N,N],[3,"CreateFuture","tokio_fs::file","Future returned by `File::create` and resolves to a `File` instance.",N,N],[3,"MetadataFuture","","Future returned by `File::metadata` and resolves to a `(Metadata, File)` instance.",N,N],[3,"OpenFuture","","Future returned by `File::open` and resolves to a `File` instance.",N,N],[3,"OpenOptions","","Options and flags which can be used to configure how a file is opened.",N,N],[3,"SeekFuture","","Future returned by `File::seek`.",N,N],[3,"File","","A reference to an open file on the filesystem.",N,N],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"poll","","",2,[[["self"]],["poll"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"poll","","",3,[[["self"]],["poll"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"poll","","",4,[[["self"]],["poll"]]],[11,"clone","tokio_fs","",5,[[["self"]],["openoptions"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"new","","Creates a blank new set of options ready for configuration.",5,[[],["openoptions"]]],[11,"read","","See the underlying [`read`] call for details.",5,[[["self"],["bool"]],["openoptions"]]],[11,"write","","See the underlying [`write`] call for details.",5,[[["self"],["bool"]],["openoptions"]]],[11,"append","","See the underlying [`append`] call for details.",5,[[["self"],["bool"]],["openoptions"]]],[11,"truncate","","See the underlying [`truncate`] call for details.",5,[[["self"],["bool"]],["openoptions"]]],[11,"create","","See the underlying [`create`] call for details.",5,[[["self"],["bool"]],["openoptions"]]],[11,"create_new","","See the underlying [`create_new`] call for details.",5,[[["self"],["bool"]],["openoptions"]]],[11,"open","","Opens a file at `path` with the options specified by `self`.",5,[[["self"],["p"]],["openfuture"]]],[11,"from","","",5,[[["stdopenoptions"]],["openoptions"]]],[11,"fmt","tokio_fs::file","",6,[[["self"],["formatter"]],["result"]]],[11,"poll","","",6,[[["self"]],["poll"]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"open","","Attempts to open a file in read-only mode.",7,[[["p"]],["openfuture"]]],[11,"create","","Opens a file in write-only mode.",7,[[["p"]],["createfuture"]]],[11,"poll_seek","","Seek to an offset, in bytes, in a stream.",7,[[["self"],["seekfrom"]],["poll",["u64","error"]]]],[11,"seek","","Seek to an offset, in bytes, in a stream.",7,[[["self"],["seekfrom"]],["seekfuture"]]],[11,"poll_sync_all","","Attempts to sync all OS-internal metadata to disk.",7,[[["self"]],["poll",["error"]]]],[11,"poll_sync_data","","This function is similar to `poll_sync_all`, except that it may not synchronize file metadata to the filesystem.",7,[[["self"]],["poll",["error"]]]],[11,"poll_set_len","","Truncates or extends the underlying file, updating the size of this file to become size.",7,[[["self"],["u64"]],["poll",["error"]]]],[11,"metadata","","Queries metadata about the underlying file.",7,[[["self"]],["metadatafuture"]]],[11,"poll_metadata","","Queries metadata about the underlying file.",7,[[["self"]],["poll",["metadata","error"]]]],[11,"poll_try_clone","","Create a new `File` instance that shares the same underlying file handle as the existing `File` instance. Reads, writes, and seeks will affect both File instances simultaneously.",7,[[["self"]],["poll",["file","error"]]]],[11,"poll_set_permissions","","Changes the permissions on the underlying file.",7,[[["self"],["permissions"]],["poll",["error"]]]],[11,"into_std","","Destructures the `tokio_fs::File` into a [`std::fs::File`][std].",7,[[["self"]],["stdfile"]]],[11,"read","","",7,N],[11,"prepare_uninitialized_buffer","","",7,N],[11,"write","","",7,N],[11,"flush","","",7,[[["self"]],["result"]]],[11,"shutdown","","",7,[[["self"]],["poll",["error"]]]],[11,"drop","","",7,[[["self"]]]],[11,"fmt","tokio_fs","",8,[[["self"],["formatter"]],["result"]]],[11,"poll","","",8,[[["self"]],["poll"]]],[11,"fmt","","",9,[[["self"],["formatter"]],["result"]]],[11,"poll","","",9,[[["self"]],["poll"]]],[0,"os","","OS-specific functionality.",N,N],[0,"unix","tokio_fs::os","Unix-specific extensions to primitives in the `tokio_fs` module.",N,N],[3,"SymlinkFuture","tokio_fs::os::unix","Future returned by `symlink`.",N,N],[5,"symlink","","Creates a new symbolic link on the filesystem.",N,[[["p"],["q"]],["symlinkfuture"]]],[11,"fmt","","",10,[[["self"],["formatter"]],["result"]]],[11,"poll","","",10,[[["self"]],["poll"]]],[11,"fmt","tokio_fs","",11,[[["self"],["formatter"]],["result"]]],[11,"poll","","",11,[[["self"]],["poll",["error"]]]],[11,"fmt","","",12,[[["self"],["formatter"]],["result"]]],[11,"poll","","",12,[[["self"]],["poll",["option"]]]],[11,"fmt","","",13,[[["self"],["formatter"]],["result"]]],[11,"into_std","","Destructures the `tokio_fs::DirEntry` into a [`std::fs::DirEntry`][std].",13,[[["self"]],["stddirentry"]]],[11,"path","","Returns the full path to the file that this entry represents.",13,[[["self"]],["pathbuf"]]],[11,"file_name","","Returns the bare file name of this directory entry without any other leading path component.",13,[[["self"]],["osstring"]]],[11,"poll_metadata","","Return the metadata for the file that this entry points at.",13,[[["self"]],["poll",["metadata","error"]]]],[11,"poll_file_type","","Return the file type for the file that this entry points at.",13,[[["self"]],["poll",["filetype","error"]]]],[11,"ino","","",13,[[["self"]],["u64"]]],[11,"fmt","","",14,[[["self"],["formatter"]],["result"]]],[11,"poll","","",14,[[["self"]],["poll"]]],[11,"fmt","","",15,[[["self"],["formatter"]],["result"]]],[11,"poll","","",15,[[["self"]],["poll"]]],[11,"fmt","","",16,[[["self"],["formatter"]],["result"]]],[11,"poll","","",16,[[["self"]],["poll"]]],[11,"fmt","","",17,[[["self"],["formatter"]],["result"]]],[11,"poll","","",17,[[["self"]],["poll"]]],[11,"fmt","","",18,[[["self"],["formatter"]],["result"]]],[11,"poll","","",18,[[["self"]],["poll"]]],[11,"fmt","","",19,[[["self"],["formatter"]],["result"]]],[11,"read","","",19,N],[11,"prepare_uninitialized_buffer","","",19,N],[11,"fmt","","",20,[[["self"],["formatter"]],["result"]]],[11,"write","","",20,N],[11,"flush","","",20,[[["self"]],["result"]]],[11,"shutdown","","",20,[[["self"]],["poll",["error"]]]],[11,"fmt","","",21,[[["self"],["formatter"]],["result"]]],[11,"write","","",21,N],[11,"flush","","",21,[[["self"]],["result"]]],[11,"shutdown","","",21,[[["self"]],["poll",["error"]]]],[11,"fmt","","",22,[[["self"],["formatter"]],["result"]]],[11,"poll","","",22,[[["self"]],["poll"]]]],"paths":[[3,"CreateDirFuture"],[3,"CreateDirAllFuture"],[3,"CreateFuture"],[3,"MetadataFuture"],[3,"OpenFuture"],[3,"OpenOptions"],[3,"SeekFuture"],[3,"File"],[3,"HardLinkFuture"],[3,"MetadataFuture"],[3,"SymlinkFuture"],[3,"ReadDirFuture"],[3,"ReadDir"],[3,"DirEntry"],[3,"ReadLinkFuture"],[3,"RemoveDirFuture"],[3,"RemoveFileFuture"],[3,"RenameFuture"],[3,"SetPermissionsFuture"],[3,"Stdin"],[3,"Stdout"],[3,"Stderr"],[3,"SymlinkMetadataFuture"]]};
searchIndex["tokio_io"]={"doc":"Core I/O traits and combinators when working with Tokio.","items":[[0,"io","tokio_io","I/O conveniences when working with primitives in `tokio-core`",N,N],[3,"AllowStdIo","tokio_io::io","A simple wrapper type which allows types that only implement `std::io::Read` or `std::io::Write` to be used in contexts which expect an `AsyncRead` or `AsyncWrite`.",N,N],[3,"Copy","","A future which will copy all data from a reader into a writer.",N,N],[3,"Flush","","A future used to fully flush an I/O object.",N,N],[3,"Lines","","Combinator created by the top-level `lines` method which is a stream over the lines of text on an I/O object.",N,N],[3,"Read","","A future which can be used to easily read available number of bytes to fill a buffer.",N,N],[3,"ReadExact","","A future which can be used to easily read exactly enough bytes to fill a buffer.",N,N],[3,"ReadToEnd","","A future which can be used to easily read the entire contents of a stream into a vector.",N,N],[3,"ReadUntil","","A future which can be used to easily read the contents of a stream into a vector until the delimiter is reached.",N,N],[3,"Shutdown","","A future used to fully shutdown an I/O object.",N,N],[3,"ReadHalf","","The readable half of an object returned from `AsyncRead::split`.",N,N],[3,"WriteHalf","","The writable half of an object returned from `AsyncRead::split`.",N,N],[3,"Window","","A owned window around an underlying buffer.",N,N],[3,"WriteAll","","A future used to write the entire contents of some data to a stream.",N,N],[5,"copy","","Creates a future which represents copying all the bytes from one object to another.",N,[[["r"],["w"]],["copy"]]],[5,"flush","","Creates a future which will entirely flush an I/O object and then yield the object itself.",N,[[["a"]],["flush"]]],[5,"lines","","Creates a new stream from the I/O object given representing the lines of input that are found on `A`.",N,[[["a"]],["lines"]]],[5,"read","","Tries to read some bytes directly into the given `buf` in asynchronous manner, returning a future type.",N,[[["r"],["t"]],["read"]]],[5,"read_exact","","Creates a future which will read exactly enough bytes to fill `buf`, returning an error if EOF is hit sooner.",N,[[["a"],["t"]],["readexact"]]],[5,"read_to_end","","Creates a future which will read all the bytes associated with the I/O object `A` into the buffer provided.",N,[[["a"],["vec",["u8"]]],["readtoend"]]],[5,"read_until","","Creates a future which will read all the bytes associated with the I/O object `A` into the buffer provided until the delimiter `byte` is reached. This method is the async equivalent to [`BufRead::read_until`].",N,[[["a"],["u8"],["vec",["u8"]]],["readuntil"]]],[5,"shutdown","","Creates a future which will entirely shutdown an I/O object and then yield the object itself.",N,[[["a"]],["shutdown"]]],[5,"write_all","","Creates a future that will write the entire contents of the buffer `buf` to the stream `a` provided.",N,[[["a"],["t"]],["writeall"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"poll","","",0,[[["self"]],["poll",["error"]]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"poll","","",1,[[["self"]],["poll",["error"]]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"poll","","",2,[[["self"]],["poll",["error"]]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"poll","","",3,[[["self"]],["poll",["error"]]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"poll","","",4,[[["self"]],["poll",["error"]]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"poll","","",5,[[["self"]],["poll",["error"]]]],[11,"fmt","","",6,[[["self"],["formatter"]],["result"]]],[11,"poll","","",6,[[["self"]],["poll",["error"]]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"poll","","",7,[[["self"]],["poll",["error"]]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result"]]],[11,"clone","","",8,[[["self"]],["allowstdio"]]],[11,"eq","","",8,[[["self"],["allowstdio"]],["bool"]]],[11,"ne","","",8,[[["self"],["allowstdio"]],["bool"]]],[11,"cmp","","",8,[[["self"],["allowstdio"]],["ordering"]]],[11,"partial_cmp","","",8,[[["self"],["allowstdio"]],["option",["ordering"]]]],[11,"lt","","",8,[[["self"],["allowstdio"]],["bool"]]],[11,"le","","",8,[[["self"],["allowstdio"]],["bool"]]],[11,"gt","","",8,[[["self"],["allowstdio"]],["bool"]]],[11,"ge","","",8,[[["self"],["allowstdio"]],["bool"]]],[11,"hash","","",8,N],[11,"new","","Creates a new `AllowStdIo` from an existing IO object.",8,[[["t"]],["self"]]],[11,"get_ref","","Returns a reference to the contained IO object.",8,[[["self"]],["t"]]],[11,"get_mut","","Returns a mutable reference to the contained IO object.",8,[[["self"]],["t"]]],[11,"into_inner","","Consumes self and returns the contained IO object.",8,[[["self"]],["t"]]],[11,"write","","",8,N],[11,"flush","","",8,[[["self"]],["result"]]],[11,"write_all","","",8,N],[11,"write_fmt","","",8,[[["self"],["arguments"]],["result"]]],[11,"shutdown","","",8,[[["self"]],["poll",["error"]]]],[11,"read","","",8,N],[11,"read_to_end","","",8,[[["self"],["vec"]],["result",["usize"]]]],[11,"read_to_string","","",8,[[["self"],["string"]],["result",["usize"]]]],[11,"read_exact","","",8,N],[11,"fmt","","",9,[[["self"],["formatter"]],["result"]]],[11,"into_inner","","Returns the underlying I/O object.",9,[[["self"]],["a"]]],[11,"poll","","",9,[[["self"]],["poll",["option","error"]]]],[11,"fmt","","",10,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",11,[[["self"],["formatter"]],["result"]]],[11,"read","","",10,N],[11,"read_buf","","",10,[[["self"],["b"]],["poll",["usize","error"]]]],[11,"write","","",11,N],[11,"flush","","",11,[[["self"]],["result"]]],[11,"shutdown","","",11,[[["self"]],["poll",["error"]]]],[11,"write_buf","","",11,[[["self"],["b"]],["poll",["usize","error"]]]],[11,"fmt","","",12,[[["self"],["formatter"]],["result"]]],[11,"new","","Creates a new window around the buffer `t` defaulting to the entire slice.",12,[[["t"]],["window"]]],[11,"get_ref","","Gets a shared reference to the underlying buffer inside of this `Window`.",12,[[["self"]],["t"]]],[11,"get_mut","","Gets a mutable reference to the underlying buffer inside of this `Window`.",12,[[["self"]],["t"]]],[11,"into_inner","","Consumes this `Window`, returning the underlying buffer.",12,[[["self"]],["t"]]],[11,"start","","Returns the starting index of this window into the underlying buffer `T`.",12,[[["self"]],["usize"]]],[11,"end","","Returns the end index of this window into the underlying buffer `T`.",12,[[["self"]],["usize"]]],[11,"set_start","","Changes the starting index of this window to the index specified.",12,[[["self"],["usize"]],["window"]]],[11,"set_end","","Changes the end index of this window to the index specified.",12,[[["self"],["usize"]],["window"]]],[11,"as_ref","","",12,N],[11,"as_mut","","",12,N],[6,"IoFuture","tokio_io","A convenience typedef around a `Future` whose error component is `io::Error`",N,N],[6,"IoStream","","A convenience typedef around a `Stream` whose error component is `io::Error`",N,N],[8,"AsyncRead","","Read bytes asynchronously.",N,N],[11,"prepare_uninitialized_buffer","","Prepares an uninitialized buffer to be safe to pass to `read`. Returns `true` if the supplied buffer was zeroed out.",13,N],[11,"poll_read","","Attempt to read from the `AsyncRead` into `buf`.",13,N],[11,"read_buf","","Pull some bytes from this source into the specified `Buf`, returning how many bytes were read.",13,[[["self"],["b"]],["poll",["usize","error"]]]],[11,"framed","","Provides a `Stream` and `Sink` interface for reading and writing to this `Io` object, using `Decode` and `Encode` to read and write the raw data.",13,[[["self"],["t"]],["framed"]]],[11,"split","","Helper method for splitting this read/write object into two halves.",13,N],[8,"AsyncWrite","","Writes bytes asynchronously.",N,N],[11,"poll_write","","Attempt to write bytes from `buf` into the object.",14,N],[11,"poll_flush","","Attempt to flush the object, ensuring that any buffered data reach their destination.",14,[[["self"]],["poll",["error"]]]],[10,"shutdown","","Initiates or attempts to shut down this writer, returning success when the I/O connection has completely shut down.",14,[[["self"]],["poll",["error"]]]],[11,"write_buf","","Write a `Buf` into this value, returning how many bytes were written.",14,[[["self"],["b"]],["poll",["usize","error"]]]],[14,"try_nb","","A convenience macro for working with `io::Result<T>` from the `Read` and `Write` traits.",N,N],[11,"prepare_uninitialized_buffer","","Prepares an uninitialized buffer to be safe to pass to `read`. Returns `true` if the supplied buffer was zeroed out.",13,N],[11,"poll_read","","Attempt to read from the `AsyncRead` into `buf`.",13,N],[11,"read_buf","","Pull some bytes from this source into the specified `Buf`, returning how many bytes were read.",13,[[["self"],["b"]],["poll",["usize","error"]]]],[11,"framed","","Provides a `Stream` and `Sink` interface for reading and writing to this `Io` object, using `Decode` and `Encode` to read and write the raw data.",13,[[["self"],["t"]],["framed"]]],[11,"split","","Helper method for splitting this read/write object into two halves.",13,N],[11,"poll_write","","Attempt to write bytes from `buf` into the object.",14,N],[11,"poll_flush","","Attempt to flush the object, ensuring that any buffered data reach their destination.",14,[[["self"]],["poll",["error"]]]],[11,"write_buf","","Write a `Buf` into this value, returning how many bytes were written.",14,[[["self"],["b"]],["poll",["usize","error"]]]]],"paths":[[3,"Copy"],[3,"Flush"],[3,"Read"],[3,"ReadExact"],[3,"ReadToEnd"],[3,"ReadUntil"],[3,"Shutdown"],[3,"WriteAll"],[3,"AllowStdIo"],[3,"Lines"],[3,"ReadHalf"],[3,"WriteHalf"],[3,"Window"],[8,"AsyncRead"],[8,"AsyncWrite"]]};
searchIndex["tokio_reactor"]={"doc":"Event loop that drives Tokio I/O resources.","items":[[3,"Background","tokio_reactor","Handle to the reactor running on a background thread.",N,N],[3,"Shutdown","","Future that resolves when the reactor thread has shutdown.",N,N],[3,"Registration","","Associates an I/O resource with the reactor instance that drives it.",N,N],[3,"PollEvented","","Associates an I/O resource that implements the [`std::io::Read`] and/or [`std::io::Write`] traits with the reactor that drives it.",N,N],[3,"Reactor","","The core reactor, or event loop.",N,N],[3,"Handle","","A reference to a reactor.",N,N],[3,"Turn","","Return value from the `turn` method on `Reactor`.",N,N],[3,"SetFallbackError","","Error returned from `Handle::set_fallback`.",N,N],[5,"with_default","","Set the default reactor for the duration of the closure",N,[[["handle"],["enter"],["f"]],["r"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"handle","","Returns a reference to the reactor handle.",0,[[["self"]],["handle"]]],[11,"shutdown_on_idle","","Shutdown the reactor on idle.",0,[[["self"]],["shutdown"]]],[11,"shutdown_now","","Shutdown the reactor immediately",0,[[["self"]],["shutdown"]]],[11,"forget","","Run the reactor on its thread until the process terminates.",0,[[["self"]]]],[11,"drop","","",0,[[["self"]]]],[11,"poll","","",1,[[["self"]],["poll"]]],[11,"new","","Creates a new `PollEvented` associated with the default reactor.",2,[[["e"]],["pollevented"]]],[11,"new_with_handle","","Creates a new `PollEvented` associated with the specified reactor.",2,[[["e"],["handle"]],["result"]]],[11,"get_ref","","Returns a shared reference to the underlying I/O object this readiness stream is wrapping.",2,[[["self"]],["e"]]],[11,"get_mut","","Returns a mutable reference to the underlying I/O object this readiness stream is wrapping.",2,[[["self"]],["e"]]],[11,"into_inner","","Consumes self, returning the inner I/O object",2,[[["self"]],["result"]]],[11,"poll_read_ready","","Check the I/O resource's read readiness state.",2,[[["self"],["ready"]],["poll",["ready","error"]]]],[11,"clear_read_ready","","Clears the I/O resource's read readiness state and registers the current task to be notified once a read readiness event is received.",2,[[["self"],["ready"]],["result"]]],[11,"poll_write_ready","","Check the I/O resource's write readiness state.",2,[[["self"]],["poll",["ready","error"]]]],[11,"clear_write_ready","","Resets the I/O resource's write readiness state and registers the current task to be notified once a write readiness event is received.",2,[[["self"]],["result"]]],[11,"read","","",2,N],[11,"write","","",2,N],[11,"flush","","",2,[[["self"]],["result"]]],[11,"shutdown","","",2,[[["self"]],["poll",["error"]]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"drop","","",2,[[["self"]]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"new","","Create a new `Registration`.",3,[[],["registration"]]],[11,"register","","Register the I/O resource with the default reactor.",3,[[["self"],["t"]],["result",["bool"]]]],[11,"deregister","","Deregister the I/O resource from the reactor it is associated with.",3,[[["self"],["t"]],["result"]]],[11,"register_with","","Register the I/O resource with the specified reactor.",3,[[["self"],["t"],["handle"]],["result",["bool"]]]],[11,"poll_read_ready","","Poll for events on the I/O resource's read readiness stream.",3,[[["self"]],["poll",["ready","error"]]]],[11,"take_read_ready","","Consume any pending read readiness event.",3,[[["self"]],["result",["option"]]]],[11,"poll_write_ready","","Poll for events on the I/O resource's write readiness stream.",3,[[["self"]],["poll",["ready","error"]]]],[11,"take_write_ready","","Consume any pending write readiness event.",3,[[["self"]],["result",["option"]]]],[11,"clone","","",4,[[["self"]],["handle"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"clone","","",6,[[["self"]],["setfallbackerror"]]],[11,"fmt","","",6,[[["self"],["formatter"]],["result"]]],[11,"new","","Creates a new event loop, returning any error that happened during the creation.",7,[[],["result",["reactor"]]]],[11,"handle","","Returns a handle to this event loop which can be sent across threads and can be used as a proxy to the event loop itself.",7,[[["self"]],["handle"]]],[11,"set_fallback","","Configures the fallback handle to be returned from `Handle::default`.",7,[[["self"]],["result",["setfallbackerror"]]]],[11,"turn","","Performs one iteration of the event loop, blocking on waiting for events for at most `max_wait` (forever if `None`).",7,[[["self"],["option",["duration"]]],["result",["turn"]]]],[11,"is_idle","","Returns true if the reactor is currently idle.",7,[[["self"]],["bool"]]],[11,"background","","Run this reactor on a background thread.",7,[[["self"]],["result",["background"]]]],[11,"unpark","","",7,N],[11,"park","","",7,[[["self"]],["result"]]],[11,"park_timeout","","",7,[[["self"],["duration"]],["result"]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"current","","Returns a handle to the current reactor.",4,[[],["handle"]]],[11,"unpark","","",4,[[["self"]]]],[11,"default","","Returns a \"default\" handle, i.e., a handle that lazily binds to a reactor.",4,[[],["handle"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",6,[[["self"],["formatter"]],["result"]]],[11,"description","","",6,[[["self"]],["str"]]]],"paths":[[3,"Background"],[3,"Shutdown"],[3,"PollEvented"],[3,"Registration"],[3,"Handle"],[3,"Turn"],[3,"SetFallbackError"],[3,"Reactor"]]};
searchIndex["tokio_signal"]={"doc":"Asynchronous signal handling for Tokio","items":[[5,"ctrl_c","tokio_signal","Creates a stream which receives \"ctrl-c\" notifications sent to a process.",N,[[],["iofuture",["iostream"]]]],[5,"ctrl_c_handle","","Creates a stream which receives \"ctrl-c\" notifications sent to a process.",N,[[["handle"]],["iofuture",["iostream"]]]],[0,"unix","","Unix-specific types for signal handling.",N,N],[17,"SIGUSR1","tokio_signal::unix","",N,N],[17,"SIGUSR2","","",N,N],[17,"SIGINT","","",N,N],[17,"SIGTERM","","",N,N],[17,"SIGALRM","","",N,N],[17,"SIGHUP","","",N,N],[17,"SIGPIPE","","",N,N],[17,"SIGQUIT","","",N,N],[17,"SIGTRAP","","",N,N],[3,"Signal","","An implementation of `Stream` for receiving a particular type of signal.",N,N],[11,"new","","Creates a new stream which will receive notifications when the current process receives the signal `signal`.",0,[[["c_int"]],["iofuture",["signal"]]]],[11,"with_handle","","Creates a new stream which will receive notifications when the current process receives the signal `signal`.",0,[[["c_int"],["handle"]],["iofuture",["signal"]]]],[11,"poll","","",0,[[["self"]],["poll",["option","error"]]]],[11,"drop","","",0,[[["self"]]]],[6,"IoFuture","tokio_signal","A future whose error is `io::Error`",N,N],[6,"IoStream","","A stream whose error is `io::Error`",N,N]],"paths":[[3,"Signal"]]};
searchIndex["tokio_tcp"]={"doc":"TCP bindings for `tokio`.","items":[[3,"Incoming","tokio_tcp","Stream returned by the `TcpListener::incoming` function representing the stream of sockets received from a listener.",N,N],[3,"TcpListener","","An I/O object representing a TCP socket listening for incoming connections.",N,N],[3,"TcpStream","","An I/O object representing a TCP stream connected to a remote endpoint.",N,N],[3,"ConnectFuture","","Future returned by `TcpStream::connect` which will resolve to a `TcpStream` when the stream is connected.",N,N],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"poll","","",0,[[["self"]],["poll",["option","error"]]]],[11,"as_raw_fd","","",1,[[["self"]],["rawfd"]]],[11,"bind","","Create a new TCP listener associated with this event loop.",1,[[["socketaddr"]],["result",["tcplistener"]]]],[11,"poll_accept","","Attempt to accept a connection and create a new connected `TcpStream` if successful.",1,[[["self"]],["poll",["error"]]]],[11,"poll_accept_std","","Attempt to accept a connection and create a new connected `TcpStream` if successful.",1,[[["self"]],["poll",["error"]]]],[11,"from_std","","Create a new TCP listener from the standard library's TCP listener.",1,[[["tcplistener"],["handle"]],["result",["tcplistener"]]]],[11,"local_addr","","Returns the local address that this listener is bound to.",1,[[["self"]],["result",["socketaddr"]]]],[11,"incoming","","Consumes this listener, returning a stream of the sockets this listener accepts.",1,[[["self"]],["incoming"]]],[11,"ttl","","Gets the value of the `IP_TTL` option for this socket.",1,[[["self"]],["result",["u32"]]]],[11,"set_ttl","","Sets the value for the `IP_TTL` option on this socket.",1,[[["self"],["u32"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"as_raw_fd","","",2,[[["self"]],["rawfd"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"connect","","Create a new TCP stream connected to the specified address.",2,[[["socketaddr"]],["connectfuture"]]],[11,"from_std","","Create a new `TcpStream` from a `net::TcpStream`.",2,[[["tcpstream"],["handle"]],["result",["tcpstream"]]]],[11,"connect_std","","Creates a new `TcpStream` from the pending socket inside the given `std::net::TcpStream`, connecting it to the address specified.",2,[[["tcpstream"],["socketaddr"],["handle"]],["connectfuture"]]],[11,"poll_read_ready","","Check the TCP stream's read readiness state.",2,[[["self"],["ready"]],["poll",["ready","error"]]]],[11,"poll_write_ready","","Check the TCP stream's write readiness state.",2,[[["self"]],["poll",["ready","error"]]]],[11,"local_addr","","Returns the local address that this stream is bound to.",2,[[["self"]],["result",["socketaddr"]]]],[11,"peer_addr","","Returns the remote address that this stream is connected to.",2,[[["self"]],["result",["socketaddr"]]]],[11,"poll_peek","","Receives data on the socket from the remote address to which it is connected, without removing that data from the queue. On success, returns the number of bytes peeked.",2,N],[11,"shutdown","","Shuts down the read, write, or both halves of this connection.",2,[[["self"],["shutdown"]],["result"]]],[11,"nodelay","","Gets the value of the `TCP_NODELAY` option on this socket.",2,[[["self"]],["result",["bool"]]]],[11,"set_nodelay","","Sets the value of the `TCP_NODELAY` option on this socket.",2,[[["self"],["bool"]],["result"]]],[11,"recv_buffer_size","","Gets the value of the `SO_RCVBUF` option on this socket.",2,[[["self"]],["result",["usize"]]]],[11,"set_recv_buffer_size","","Sets the value of the `SO_RCVBUF` option on this socket.",2,[[["self"],["usize"]],["result"]]],[11,"send_buffer_size","","Gets the value of the `SO_SNDBUF` option on this socket.",2,[[["self"]],["result",["usize"]]]],[11,"set_send_buffer_size","","Sets the value of the `SO_SNDBUF` option on this socket.",2,[[["self"],["usize"]],["result"]]],[11,"keepalive","","Returns whether keepalive messages are enabled on this socket, and if so the duration of time between them.",2,[[["self"]],["result",["option"]]]],[11,"set_keepalive","","Sets whether keepalive messages are enabled to be sent on this socket.",2,[[["self"],["option",["duration"]]],["result"]]],[11,"ttl","","Gets the value of the `IP_TTL` option for this socket.",2,[[["self"]],["result",["u32"]]]],[11,"set_ttl","","Sets the value for the `IP_TTL` option on this socket.",2,[[["self"],["u32"]],["result"]]],[11,"linger","","Reads the linger duration for this socket by getting the `SO_LINGER` option.",2,[[["self"]],["result",["option"]]]],[11,"set_linger","","Sets the linger duration of this socket by setting the `SO_LINGER` option.",2,[[["self"],["option",["duration"]]],["result"]]],[11,"try_clone","","Creates a new independently owned handle to the underlying socket.",2,[[["self"]],["result",["tcpstream"]]]],[11,"read","","",2,N],[11,"write","","",2,N],[11,"flush","","",2,[[["self"]],["result"]]],[11,"prepare_uninitialized_buffer","","",2,N],[11,"read_buf","","",2,[[["self"],["b"]],["poll",["usize","error"]]]],[11,"shutdown","","",2,[[["self"]],["poll",["error"]]]],[11,"write_buf","","",2,[[["self"],["b"]],["poll",["usize","error"]]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"poll","","",3,[[["self"]],["poll",["tcpstream","error"]]]]],"paths":[[3,"Incoming"],[3,"TcpListener"],[3,"TcpStream"],[3,"ConnectFuture"]]};
searchIndex["tokio_threadpool"]={"doc":"A work-stealing based thread pool for executing futures.","items":[[3,"BlockingError","tokio_threadpool","Error raised by `blocking`.",N,N],[3,"Builder","","Builds a thread pool with custom configuration values.",N,N],[3,"Sender","","Submit futures to the associated thread pool for execution.",N,N],[3,"Shutdown","","Future that resolves when the thread pool is shutdown.",N,N],[3,"ThreadPool","","Work-stealing based thread pool for executing futures.",N,N],[3,"SpawnHandle","","Handle returned from ThreadPool::spawn_handle.",N,N],[3,"Worker","","Thread worker",N,N],[3,"WorkerId","","Identifies a thread pool worker.",N,N],[5,"blocking","","Enter a blocking section of code.",N,[[["f"]],["poll",["blockingerror"]]]],[0,"park","","Thread parking utilities.",N,N],[3,"DefaultPark","tokio_threadpool::park","Parks the thread.",N,N],[3,"DefaultUnpark","","Unparks threads that were parked by `DefaultPark`.",N,N],[3,"ParkError","","Error returned by [`ParkThread`]",N,N],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"new","","Creates a new `DefaultPark` instance.",0,[[],["defaultpark"]]],[11,"unpark","","",0,N],[11,"park","","",0,[[["self"]],["result"]]],[11,"park_timeout","","",0,[[["self"],["duration"]],["result"]]],[11,"unpark","","",1,[[["self"]]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"description","","",2,[[["self"]],["str"]]],[11,"fmt","tokio_threadpool","",3,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"description","","",3,[[["self"]],["str"]]],[11,"new","","Returns a new thread pool builder initialized with default configuration values.",4,[[],["builder"]]],[11,"pool_size","","Set the maximum number of worker threads for the thread pool instance.",4,[[["self"],["usize"]],["self"]]],[11,"max_blocking","","Set the maximum number of concurrent blocking sections.",4,[[["self"],["usize"]],["self"]]],[11,"keep_alive","","Set the worker thread keep alive duration",4,[[["self"],["option",["duration"]]],["self"]]],[11,"name_prefix","","Set name prefix of threads spawned by the scheduler",4,[[["self"],["s"]],["self"]]],[11,"stack_size","","Set the stack size (in bytes) for worker threads.",4,[[["self"],["usize"]],["self"]]],[11,"around_worker","","Execute function `f` on each worker thread.",4,[[["self"],["f"]],["self"]]],[11,"after_start","","Execute function `f` after each thread is started but before it starts doing work.",4,[[["self"],["f"]],["self"]]],[11,"before_stop","","Execute function `f` before each thread stops.",4,[[["self"],["f"]],["self"]]],[11,"custom_park","","Customize the `park` instance used by each worker thread.",4,[[["self"],["f"]],["self"]]],[11,"build","","Create the configured `ThreadPool`.",4,[[["self"]],["threadpool"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"spawn","","Spawn a future onto the thread pool",5,[[["self"],["f"]],["result",["spawnerror"]]]],[11,"status","","",5,[[["self"]],["result",["spawnerror"]]]],[11,"spawn","","",5,[[["self"],["box",["future"]]],["result",["spawnerror"]]]],[11,"execute","","",5,[[["self"],["t"]],["result",["executeerror"]]]],[11,"clone","","",5,[[["self"]],["sender"]]],[11,"fmt","","",6,[[["self"],["formatter"]],["result"]]],[11,"poll","","",6,[[["self"]],["poll"]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"new","","Create a new `ThreadPool` with default values.",7,[[],["threadpool"]]],[11,"spawn","","Spawn a future onto the thread pool.",7,[[["self"],["f"]]]],[11,"spawn_handle","","Spawn a future on to the thread pool, return a future representing  the produced value.",7,[[["self"],["f"]],["spawnhandle"]]],[11,"sender","","Return a reference to the sender handle",7,[[["self"]],["sender"]]],[11,"sender_mut","","Return a mutable reference to the sender handle",7,[[["self"]],["sender"]]],[11,"shutdown_on_idle","","Shutdown the pool once it becomes idle.",7,[[["self"]],["shutdown"]]],[11,"shutdown","","Shutdown the pool",7,[[["self"]],["shutdown"]]],[11,"shutdown_now","","Shutdown the pool immediately",7,[[["self"]],["shutdown"]]],[11,"drop","","",7,[[["self"]]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result"]]],[11,"poll","","",8,[[["self"]],["poll"]]],[11,"fmt","","",9,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",10,[[["self"],["formatter"]],["result"]]],[11,"clone","","",10,[[["self"]],["workerid"]]],[11,"hash","","",10,N],[11,"eq","","",10,[[["self"],["workerid"]],["bool"]]],[11,"ne","","",10,[[["self"],["workerid"]],["bool"]]],[11,"id","","Returns a reference to the worker's identifier.",9,[[["self"]],["workerid"]]],[11,"run","","Run the worker",9,[[["self"]]]],[11,"drop","","",9,[[["self"]]]]],"paths":[[3,"DefaultPark"],[3,"DefaultUnpark"],[3,"ParkError"],[3,"BlockingError"],[3,"Builder"],[3,"Sender"],[3,"Shutdown"],[3,"ThreadPool"],[3,"SpawnHandle"],[3,"Worker"],[3,"WorkerId"]]};
searchIndex["tokio_timer"]={"doc":"Utilities for tracking time.","items":[[3,"DelayQueue","tokio_timer","A queue of delayed elements.",N,N],[3,"Delay","","A future that completes at a specified instant in time.",N,N],[3,"Error","","Errors encountered by the timer implementation.",N,N],[3,"Interval","","A stream representing notifications at fixed interval",N,N],[3,"Timeout","","Allows a `Future` or `Stream` to execute for a limited amount of time.",N,N],[5,"with_default","","Set the default timer for the duration of the closure.",N,[[["handle"],["enter"],["f"]],["r"]]],[5,"sleep","","Create a Future that completes in `duration` from now.",N,[[["duration"]],["delay"]]],[0,"clock","","A configurable source of time.",N,N],[3,"Clock","tokio_timer::clock","A handle to a source of time.",N,N],[5,"now","","Returns an `Instant` corresponding to \"now\".",N,[[],["instant"]]],[5,"with_default","","Set the default clock for the duration of the closure.",N,[[["clock"],["enter"],["f"]],["r"]]],[11,"default","","",0,[[],["clock"]]],[11,"clone","","",0,[[["self"]],["clock"]]],[11,"new","","Return a new `Clock` instance that uses the current execution context's source of time.",0,[[],["clock"]]],[11,"new_with_now","","Return a new `Clock` instance that uses `now` as the source of time.",0,[[["t"]],["clock"]]],[11,"system","","Return a new `Clock` instance that uses `Instant::now()` as the source of time.",0,[[],["clock"]]],[11,"now","","Returns an instant corresponding to \"now\" by using the instance's source of time.",0,[[["self"]],["instant"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[8,"Now","","Returns `Instant` values representing the current instant in time.",N,N],[10,"now","","Returns an instant corresponding to \"now\".",1,[[["self"]],["instant"]]],[0,"delay_queue","tokio_timer","A queue of delayed elements.",N,N],[3,"DelayQueue","tokio_timer::delay_queue","A queue of delayed elements.",N,N],[3,"Expired","","An entry in `DelayQueue` that has expired and removed.",N,N],[3,"Key","","Token to a value stored in a `DelayQueue`.",N,N],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"new","","Create a new, empty, `DelayQueue`",2,[[],["delayqueue"]]],[11,"with_capacity_and_handle","","Create a new, empty, `DelayQueue` backed by the specified timer.",2,[[["usize"],["handle"]],["delayqueue"]]],[11,"with_capacity","","Create a new, empty, `DelayQueue` with the specified capacity.",2,[[["usize"]],["delayqueue"]]],[11,"insert_at","","Insert `value` into the queue set to expire at a specific instant in time.",2,[[["self"],["t"],["instant"]],["key"]]],[11,"insert","","Insert `value` into the queue set to expire after the requested duration elapses.",2,[[["self"],["t"],["duration"]],["key"]]],[11,"remove","","Remove the item associated with `key` from the queue.",2,[[["self"],["key"]],["expired"]]],[11,"reset_at","","Sets the delay of the item associated with `key` to expire at `when`.",2,[[["self"],["key"],["instant"]]]],[11,"reset","","Sets the delay of the item associated with `key` to expire after `timeout`.",2,[[["self"],["key"],["duration"]]]],[11,"clear","","Clears the queue, removing all items.",2,[[["self"]]]],[11,"capacity","","Returns the number of elements the queue can hold without reallocating.",2,[[["self"]],["usize"]]],[11,"reserve","","Reserve capacity for at least `additional` more items to be queued without allocating.",2,[[["self"],["usize"]]]],[11,"is_empty","","Returns `true` if there are no items in the queue.",2,[[["self"]],["bool"]]],[11,"poll","","",2,[[["self"]],["poll",["option","error"]]]],[11,"get_ref","","Returns a reference to the inner value.",3,[[["self"]],["t"]]],[11,"get_mut","","Returns a mutable reference to the inner value.",3,[[["self"]],["t"]]],[11,"into_inner","","Consumes `self` and returns the inner value.",3,[[["self"]],["t"]]],[0,"timeout","tokio_timer","Allows a future or stream to execute for a maximum amount of time.",N,N],[3,"Timeout","tokio_timer::timeout","Allows a `Future` or `Stream` to execute for a limited amount of time.",N,N],[3,"Error","","Error returned by `Timeout`.",N,N],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",6,[[["self"],["formatter"]],["result"]]],[11,"new","","Create a new `Timeout` that allows `value` to execute for a duration of at most `timeout`.",5,[[["t"],["duration"]],["timeout"]]],[11,"get_ref","","Gets a reference to the underlying value in this timeout.",5,[[["self"]],["t"]]],[11,"get_mut","","Gets a mutable reference to the underlying value in this timeout.",5,[[["self"]],["t"]]],[11,"into_inner","","Consumes this timeout, returning the underlying value.",5,[[["self"]],["t"]]],[11,"new_at","","Create a new `Timeout` that completes when `future` completes or when `deadline` is reached.",5,[[["t"],["instant"]],["timeout"]]],[11,"poll","","",5,[[["self"]],["poll"]]],[11,"poll","","",5,[[["self"]],["poll",["option"]]]],[11,"inner","","Create a new `Error` representing the inner value completing with `Err`.",6,[[["t"]],["error"]]],[11,"is_inner","","Returns `true` if the error was caused by the inner value completing with `Err`.",6,[[["self"]],["bool"]]],[11,"into_inner","","Consumes `self`, returning the inner future error.",6,[[["self"]],["option"]]],[11,"elapsed","","Create a new `Error` representing the inner value not completing before the deadline is reached.",6,[[],["error"]]],[11,"is_elapsed","","Returns `true` if the error was caused by the inner value not completing before the deadline is reached.",6,[[["self"]],["bool"]]],[11,"timer","","Creates a new `Error` representing an error encountered by the timer implementation",6,[[["error"]],["error"]]],[11,"is_timer","","Returns `true` if the error was caused by the timer.",6,[[["self"]],["bool"]]],[11,"into_timer","","Consumes `self`, returning the error raised by the timer implementation.",6,[[["self"]],["option",["error"]]]],[11,"description","","",6,[[["self"]],["str"]]],[11,"fmt","","",6,[[["self"],["formatter"]],["result"]]],[0,"timer","tokio_timer","Timer implementation.",N,N],[3,"Handle","tokio_timer::timer","Handle to timer instance.",N,N],[3,"SystemNow","","A handle to a source of time.",N,N],[3,"Timer","","Timer implementation that drives [`Delay`], [`Interval`], and [`Deadline`].",N,N],[3,"Turn","","Return value from the `turn` method on `Timer`.",N,N],[5,"with_default","","Set the default timer for the duration of the closure.",N,[[["handle"],["enter"],["f"]],["r"]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"clone","","",7,[[["self"]],["handle"]]],[11,"current","","Returns a handle to the current timer.",7,[[],["handle"]]],[11,"delay","","Create a `Delay` driven by this handle's associated `Timer`.",7,[[["self"],["instant"]],["delay"]]],[11,"deadline","","Create a `Deadline` driven by this handle's associated `Timer`.",7,[[["self"],["t"],["instant"]],["deadline"]]],[11,"interval","","Create a new `Interval` that starts at `at` and yields every `duration` interval after that.",7,[[["self"],["instant"],["duration"]],["interval"]]],[11,"default","","",7,[[],["handle"]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",9,[[["self"],["formatter"]],["result"]]],[11,"new","","Create a new `Timer` instance that uses `park` to block the current thread.",8,[[["t"]],["self"]]],[11,"get_park","","Returns a reference to the underlying `Park` instance.",8,[[["self"]],["t"]]],[11,"get_park_mut","","Returns a mutable reference to the underlying `Park` instance.",8,[[["self"]],["t"]]],[11,"new_with_now","","Create a new `Timer` instance that uses `park` to block the current thread and `now` to get the current `Instant`.",8,[[["t"],["n"]],["self"]]],[11,"handle","","Returns a handle to the timer.",8,[[["self"]],["handle"]]],[11,"turn","","Performs one iteration of the timer loop.",8,[[["self"],["option",["duration"]]],["result",["turn"]]]],[11,"default","","",8,[[],["self"]]],[11,"unpark","","",8,N],[11,"park","","",8,[[["self"]],["result"]]],[11,"park_timeout","","",8,[[["self"],["duration"]],["result"]]],[11,"drop","","",8,[[["self"]]]],[11,"fmt","tokio_timer","",10,[[["self"],["formatter"]],["result"]]],[11,"new","","Create a new `Delay` instance that elapses at `deadline`.",10,[[["instant"]],["delay"]]],[11,"deadline","","Returns the instant at which the future will complete.",10,[[["self"]],["instant"]]],[11,"is_elapsed","","Returns true if the `Delay` has elapsed",10,[[["self"]],["bool"]]],[11,"reset","","Reset the `Delay` instance to a new deadline.",10,[[["self"],["instant"]]]],[11,"poll","","",10,[[["self"]],["poll"]]],[11,"fmt","","",11,[[["self"],["formatter"]],["result"]]],[11,"shutdown","","Create an error representing a shutdown timer.",11,[[],["error"]]],[11,"is_shutdown","","Returns `true` if the error was caused by the timer being shutdown.",11,[[["self"]],["bool"]]],[11,"at_capacity","","Create an error representing a timer at capacity.",11,[[],["error"]]],[11,"is_at_capacity","","Returns `true` if the error was caused by the timer being at capacity.",11,[[["self"]],["bool"]]],[11,"description","","",11,[[["self"]],["str"]]],[11,"fmt","","",11,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",12,[[["self"],["formatter"]],["result"]]],[11,"new","","Create a new `Interval` that starts at `at` and yields every `duration` interval after that.",12,[[["instant"],["duration"]],["interval"]]],[11,"new_interval","","Creates new `Interval` that yields with interval of `duration`.",12,[[["duration"]],["interval"]]],[11,"poll","","",12,[[["self"]],["poll",["option"]]]]],"paths":[[3,"Clock"],[8,"Now"],[3,"DelayQueue"],[3,"Expired"],[3,"Key"],[3,"Timeout"],[3,"Error"],[3,"Handle"],[3,"Timer"],[3,"Turn"],[3,"Delay"],[3,"Error"],[3,"Interval"]]};
searchIndex["tokio_tls"]={"doc":"Async TLS streams","items":[[3,"TlsStream","tokio_tls","A wrapper around an underlying raw stream which implements the TLS or SSL protocol.",N,N],[3,"TlsConnector","","A wrapper around a `native_tls::TlsConnector`, providing an async `connect` method.",N,N],[3,"TlsAcceptor","","A wrapper around a `native_tls::TlsAcceptor`, providing an async `accept` method.",N,N],[3,"Connect","","Future returned from `TlsConnector::connect` which will resolve once the connection handshake has finished.",N,N],[3,"Accept","","Future returned from `TlsAcceptor::accept` which will resolve once the accept handshake has finished.",N,N],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"get_ref","","Get access to the internal `native_tls::TlsStream` stream which also transitively allows access to `S`.",0,[[["self"]],["tlsstream"]]],[11,"get_mut","","Get mutable access to the internal `native_tls::TlsStream` stream which also transitively allows mutable access to `S`.",0,[[["self"]],["tlsstream"]]],[11,"read","","",0,N],[11,"write","","",0,N],[11,"flush","","",0,[[["self"]],["result"]]],[11,"shutdown","","",0,[[["self"]],["poll",["error"]]]],[11,"connect","","Connects the provided stream with this connector, assuming the provided domain.",1,[[["self"],["str"],["s"]],["connect"]]],[11,"from","","",1,[[["tlsconnector"]],["tlsconnector"]]],[11,"accept","","Accepts a new client connection with the provided stream.",2,[[["self"],["s"]],["accept"]]],[11,"from","","",2,[[["tlsacceptor"]],["tlsacceptor"]]],[11,"poll","","",3,[[["self"]],["poll",["tlsstream","error"]]]],[11,"poll","","",4,[[["self"]],["poll",["tlsstream","error"]]]]],"paths":[[3,"TlsStream"],[3,"TlsConnector"],[3,"TlsAcceptor"],[3,"Connect"],[3,"Accept"]]};
searchIndex["tokio_udp"]={"doc":"UDP bindings for `tokio`.","items":[[3,"UdpFramed","tokio_udp","A unified `Stream` and `Sink` interface to an underlying `UdpSocket`, using the `Encoder` and `Decoder` traits to encode and decode frames.",N,N],[3,"UdpSocket","","An I/O object representing a UDP socket.",N,N],[3,"SendDgram","","A future used to write the entire contents of some data to a UDP socket.",N,N],[3,"RecvDgram","","A future used to receive a datagram from a UDP socket.",N,N],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"poll","","",0,[[["self"]],["poll",["option"]]]],[11,"start_send","","",0,N],[11,"poll_complete","","",0,[[["self"]],["poll"]]],[11,"close","","",0,[[["self"]],["poll"]]],[11,"new","","Create a new `UdpFramed` backed by the given socket and codec.",0,[[["udpsocket"],["c"]],["udpframed"]]],[11,"get_ref","","Returns a reference to the underlying I/O stream wrapped by `Framed`.",0,[[["self"]],["udpsocket"]]],[11,"get_mut","","Returns a mutable reference to the underlying I/O stream wrapped by `Framed`.",0,[[["self"]],["udpsocket"]]],[11,"into_inner","","Consumes the `Framed`, returning its underlying I/O stream.",0,[[["self"]],["udpsocket"]]],[11,"as_raw_fd","","",1,[[["self"]],["rawfd"]]],[11,"bind","","This function will create a new UDP socket and attempt to bind it to the `addr` provided.",1,[[["socketaddr"]],["result",["udpsocket"]]]],[11,"from_std","","Creates a new `UdpSocket` from the previously bound socket provided.",1,[[["udpsocket"],["handle"]],["result",["udpsocket"]]]],[11,"local_addr","","Returns the local address that this socket is bound to.",1,[[["self"]],["result",["socketaddr"]]]],[11,"connect","","Connects the UDP socket setting the default destination for send() and limiting packets that are read via recv from the address specified in `addr`.",1,[[["self"],["socketaddr"]],["result"]]],[11,"poll_send","","Sends data on the socket to the remote address to which it is connected.",1,N],[11,"poll_recv","","Receives a single datagram message on the socket from the remote address to which it is connected. On success, returns the number of bytes read.",1,N],[11,"poll_send_to","","Sends data on the socket to the given address. On success, returns the number of bytes written.",1,N],[11,"send_dgram","","Creates a future that will write the entire contents of the buffer `buf` provided as a datagram to this socket.",1,[[["self"],["t"],["socketaddr"]],["senddgram"]]],[11,"poll_recv_from","","Receives data from the socket. On success, returns the number of bytes read and the address from whence the data came.",1,N],[11,"recv_dgram","","Creates a future that receive a datagram to be written to the buffer provided.",1,[[["self"],["t"]],["recvdgram"]]],[11,"poll_read_ready","","Check the UDP socket's read readiness state.",1,[[["self"],["ready"]],["poll",["ready","error"]]]],[11,"poll_write_ready","","Check the UDP socket's write readiness state.",1,[[["self"]],["poll",["ready","error"]]]],[11,"broadcast","","Gets the value of the `SO_BROADCAST` option for this socket.",1,[[["self"]],["result",["bool"]]]],[11,"set_broadcast","","Sets the value of the `SO_BROADCAST` option for this socket.",1,[[["self"],["bool"]],["result"]]],[11,"multicast_loop_v4","","Gets the value of the `IP_MULTICAST_LOOP` option for this socket.",1,[[["self"]],["result",["bool"]]]],[11,"set_multicast_loop_v4","","Sets the value of the `IP_MULTICAST_LOOP` option for this socket.",1,[[["self"],["bool"]],["result"]]],[11,"multicast_ttl_v4","","Gets the value of the `IP_MULTICAST_TTL` option for this socket.",1,[[["self"]],["result",["u32"]]]],[11,"set_multicast_ttl_v4","","Sets the value of the `IP_MULTICAST_TTL` option for this socket.",1,[[["self"],["u32"]],["result"]]],[11,"multicast_loop_v6","","Gets the value of the `IPV6_MULTICAST_LOOP` option for this socket.",1,[[["self"]],["result",["bool"]]]],[11,"set_multicast_loop_v6","","Sets the value of the `IPV6_MULTICAST_LOOP` option for this socket.",1,[[["self"],["bool"]],["result"]]],[11,"ttl","","Gets the value of the `IP_TTL` option for this socket.",1,[[["self"]],["result",["u32"]]]],[11,"set_ttl","","Sets the value for the `IP_TTL` option on this socket.",1,[[["self"],["u32"]],["result"]]],[11,"join_multicast_v4","","Executes an operation of the `IP_ADD_MEMBERSHIP` type.",1,[[["self"],["ipv4addr"],["ipv4addr"]],["result"]]],[11,"join_multicast_v6","","Executes an operation of the `IPV6_ADD_MEMBERSHIP` type.",1,[[["self"],["ipv6addr"],["u32"]],["result"]]],[11,"leave_multicast_v4","","Executes an operation of the `IP_DROP_MEMBERSHIP` type.",1,[[["self"],["ipv4addr"],["ipv4addr"]],["result"]]],[11,"leave_multicast_v6","","Executes an operation of the `IPV6_DROP_MEMBERSHIP` type.",1,[[["self"],["ipv6addr"],["u32"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"poll","","",2,[[["self"]],["poll",["error"]]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"poll","","",3,[[["self"]],["poll",["error"]]]]],"paths":[[3,"UdpFramed"],[3,"UdpSocket"],[3,"SendDgram"],[3,"RecvDgram"]]};
searchIndex["tokio_uds"]={"doc":"Unix Domain Sockets for Tokio.","items":[[3,"UnixDatagram","tokio_uds","An I/O object representing a Unix datagram socket.",N,N],[3,"Incoming","","Stream of listeners",N,N],[3,"UnixListener","","A Unix socket which can accept connections from other Unix sockets.",N,N],[3,"RecvDgram","","A future for receiving datagrams from a Unix datagram socket.",N,N],[3,"SendDgram","","A future for writing a buffer to a Unix datagram socket.",N,N],[3,"UnixStream","","A structure representing a connected Unix socket.",N,N],[3,"ConnectFuture","","Future returned by `UnixStream::connect` which will resolve to a `UnixStream` when the stream is connected.",N,N],[3,"UCred","","Credentials of a process",N,N],[12,"uid","","UID (user ID) of the process",0,N],[12,"gid","","GID (group ID) of the process",0,N],[11,"bind","","Creates a new `UnixDatagram` bound to the specified path.",1,[[["p"]],["result",["unixdatagram"]]]],[11,"pair","","Creates an unnamed pair of connected sockets.",1,[[],["result"]]],[11,"from_std","","Consumes a `UnixDatagram` in the standard library and returns a nonblocking `UnixDatagram` from this crate.",1,[[["unixdatagram"],["handle"]],["result",["unixdatagram"]]]],[11,"unbound","","Creates a new `UnixDatagram` which is not bound to any address.",1,[[],["result",["unixdatagram"]]]],[11,"connect","","Connects the socket to the specified address.",1,[[["self"],["p"]],["result"]]],[11,"poll_read_ready","","Test whether this socket is ready to be read or not.",1,[[["self"],["ready"]],["poll",["ready","error"]]]],[11,"poll_write_ready","","Test whether this socket is ready to be written to or not.",1,[[["self"]],["poll",["ready","error"]]]],[11,"local_addr","","Returns the local address that this socket is bound to.",1,[[["self"]],["result",["socketaddr"]]]],[11,"peer_addr","","Returns the address of this socket's peer.",1,[[["self"]],["result",["socketaddr"]]]],[11,"poll_recv_from","","Receives data from the socket.",1,N],[11,"poll_recv","","Receives data from the socket.",1,N],[11,"recv_dgram","","Returns a future for receiving a datagram. See the documentation on RecvDgram for details.",1,[[["self"],["t"]],["recvdgram"]]],[11,"poll_send_to","","Sends data on the socket to the specified address.",1,N],[11,"poll_send","","Sends data on the socket to the socket's peer.",1,N],[11,"send_dgram","","Returns a future sending the data in buf to the socket at path.",1,[[["self"],["t"],["p"]],["senddgram"]]],[11,"take_error","","Returns the value of the `SO_ERROR` option.",1,[[["self"]],["result",["option"]]]],[11,"shutdown","","Shut down the read, write, or both halves of this connection.",1,[[["self"],["shutdown"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"as_raw_fd","","",1,[[["self"]],["rawfd"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"poll","","",2,[[["self"]],["poll",["option","error"]]]],[11,"bind","","Creates a new `UnixListener` bound to the specified path.",3,[[["p"]],["result",["unixlistener"]]]],[11,"from_std","","Consumes a `UnixListener` in the standard library and returns a nonblocking `UnixListener` from this crate.",3,[[["unixlistener"],["handle"]],["result",["unixlistener"]]]],[11,"local_addr","","Returns the local socket address of this listener.",3,[[["self"]],["result",["socketaddr"]]]],[11,"poll_read_ready","","Test whether this socket is ready to be read or not.",3,[[["self"],["ready"]],["poll",["ready","error"]]]],[11,"take_error","","Returns the value of the `SO_ERROR` option.",3,[[["self"]],["result",["option"]]]],[11,"poll_accept","","Attempt to accept a connection and create a new connected `UnixStream` if successful.",3,[[["self"]],["poll",["error"]]]],[11,"poll_accept_std","","Attempt to accept a connection and create a new connected `UnixStream` if successful.",3,[[["self"]],["poll",["error"]]]],[11,"incoming","","Consumes this listener, returning a stream of the sockets this listener accepts.",3,[[["self"]],["incoming"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"as_raw_fd","","",3,[[["self"]],["rawfd"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"poll","","",4,[[["self"]],["poll"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"poll","","",5,[[["self"]],["poll"]]],[11,"fmt","","",6,[[["self"],["formatter"]],["result"]]],[11,"connect","","Connects to the socket named by `path`.",7,[[["p"]],["connectfuture"]]],[11,"from_std","","Consumes a `UnixStream` in the standard library and returns a nonblocking `UnixStream` from this crate.",7,[[["unixstream"],["handle"]],["result",["unixstream"]]]],[11,"pair","","Creates an unnamed pair of connected sockets.",7,[[],["result"]]],[11,"poll_read_ready","","Test whether this socket is ready to be read or not.",7,[[["self"],["ready"]],["poll",["ready","error"]]]],[11,"poll_write_ready","","Test whether this socket is ready to be written to or not.",7,[[["self"]],["poll",["ready","error"]]]],[11,"local_addr","","Returns the socket address of the local half of this connection.",7,[[["self"]],["result",["socketaddr"]]]],[11,"peer_addr","","Returns the socket address of the remote half of this connection.",7,[[["self"]],["result",["socketaddr"]]]],[11,"peer_cred","","Returns effective credentials of the process which called `connect` or `socketpair`.",7,[[["self"]],["result",["ucred"]]]],[11,"take_error","","Returns the value of the `SO_ERROR` option.",7,[[["self"]],["result",["option"]]]],[11,"shutdown","","Shuts down the read, write, or both halves of this connection.",7,[[["self"],["shutdown"]],["result"]]],[11,"read","","",7,N],[11,"write","","",7,N],[11,"flush","","",7,[[["self"]],["result"]]],[11,"prepare_uninitialized_buffer","","",7,N],[11,"read_buf","","",7,[[["self"],["b"]],["poll",["usize","error"]]]],[11,"shutdown","","",7,[[["self"]],["poll",["error"]]]],[11,"write_buf","","",7,[[["self"],["b"]],["poll",["usize","error"]]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"as_raw_fd","","",7,[[["self"]],["rawfd"]]],[11,"poll","","",6,[[["self"]],["poll",["unixstream","error"]]]],[11,"clone","","",0,[[["self"]],["ucred"]]],[11,"eq","","",0,[[["self"],["ucred"]],["bool"]]],[11,"ne","","",0,[[["self"],["ucred"]],["bool"]]],[11,"hash","","",0,N],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]]],"paths":[[3,"UCred"],[3,"UnixDatagram"],[3,"Incoming"],[3,"UnixListener"],[3,"RecvDgram"],[3,"SendDgram"],[3,"ConnectFuture"],[3,"UnixStream"]]};
initSearch(searchIndex);
